!function(e){var n={};function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)t.d(r,o,function(n){return e[n]}.bind(null,o));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=541)}({541:function(e,n,t){"use strict";function r(e){return"vec2( ".concat(this.float(e[0]),", ").concat(this.float(e[1]),"  )")}function o(e){return"vec3( ".concat(this.float(e[0]),", ").concat(this.float(e[1]),", ").concat(this.float(e[2])," )")}function i(e){return"vec4( ".concat(this.float(e[0]),", ").concat(this.float(e[1]),", ").concat(this.float(e[2]),", ").concat(this.float(e[3])," )")}function a(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,t=e.toFixed(n);return t.includes(".")?t=t.replace(/0+$/,"")+"0":t+=".0",t}function c(e){return{min:this.vec3(e.min.toArray()),max:this.vec3(e.max.toArray())}}function u(e){return e instanceof RK.Matrix4?this.mat4(e):e instanceof RK.Box3?this.box3(e):((e instanceof RK.Vec2||e instanceof RK.Vec3||e instanceof RK.Vec4)&&(e=e.toArray()),"number"==typeof e?this.float(e):this["vec"+e.length](e))}function s(e){var n=e.clone().transpose().elements;return"mat4("+this.vec4(n.slice(0,4))+","+this.vec4(n.slice(4,8))+","+this.vec4(n.slice(8,12))+","+this.vec4(n.slice(12,16))+")"}function l(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function f(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}t.r(n),t.d(n,"ColorLayersPhysical",(function(){return ac})),t.d(n,"Physical",(function(){return uo})),t.d(n,"BasicTextured",(function(){return bo})),t.d(n,"TextureBlend",(function(){return Po})),t.d(n,"Depth",(function(){return jo})),t.d(n,"GatherAO",(function(){return Eo})),t.d(n,"LightMaterial",(function(){return Yo})),t.d(n,"UvSeamMaterial",(function(){return di})),t.d(n,"UvStretchMaterial",(function(){return ti})),t.d(n,"Shader",(function(){return m})),t.d(n,"Cube",(function(){return Mi})),t.d(n,"ShadowReceiver",(function(){return Hi})),t.d(n,"Custom",(function(){return oa})),t.d(n,"Material",(function(){return be})),t.d(n,"EffectPass",(function(){return ca})),t.d(n,"Basic",(function(){return ha})),t.d(n,"BakeLayers",(function(){return ka})),t.d(n,"Map",(function(){return Va})),t.d(n,"ID",(function(){return Ya})),t.d(n,"DepthTileMaterial",(function(){return gc})),t.d(n,"OcclusionMaterial",(function(){return Rc})),t.d(n,"ReflectorMaterial",(function(){return Gc})),t.d(n,"FogMaterial",(function(){return Qc})),t.d(n,"AccumulateOcclusion",(function(){return ru})),t.d(n,"ResolveOcclusion",(function(){return su})),t.d(n,"chunks",(function(){return lu})),t.d(n,"vec2",(function(){return r})),t.d(n,"vec3",(function(){return o})),t.d(n,"vec4",(function(){return i})),t.d(n,"float",(function(){return a})),t.d(n,"box3",(function(){return c})),t.d(n,"toSL",(function(){return u})),t.d(n,"mat4",(function(){return s}));var p=function(){function e(){var n=this,t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];l(this,e),this.isVertexShader=t,this.isFragmentShader=!t,this.es3=r,this._sections={parsStart:[],pars:[],main:[]},this.uniforms={},this.extensions={},this.debugVars=[],this.vars={},this.m=function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),o=1;o<t;o++)r[o-1]=arguments[o];n.addTag(e,r,"main")},this.m.p=function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),o=1;o<t;o++)r[o-1]=arguments[o];n.addTag(e,r,"pars")},this.m.s=function(e,t){n.addString(t,e)},this.m.section=function(e){n.addSection(e)},this.m.extension=function(e){n.extensions[e]=!0},this.m.addVar=function(e,t,r){n.addVar(e,t,r)},this.m.u=function(e){n.addUniform(e)},this.m.uniforms=this.uniforms,this.m.addFunc=function(e,t){n.addFunc(e,t)},this.addSection("start")}var n,t,r;return n=e,r=[{key:"addLiteral",value:function(e,n,t){e.push(n[0]);for(var r=1,o=n.length;r<o;r++)e.push(t[r-1]),e.push(n[r]);e.push("\n")}}],(t=[{key:"addFunc",value:function(n,t){void 0!==this.m[n]&&console.error("Function",n,"already added");var r=[t];this._sections.pars.push(r),this.m[n]=function(n){for(var t=arguments.length,o=new Array(t>1?t-1:0),i=1;i<t;i++)o[i-1]=arguments[i];e.addLiteral(r,n,o)},this._sections.pars.push("}")}},{key:"comment",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"start";this.addString("//"+e,n)}},{key:"addVar",value:function(e,n,t){n in this.vars?this.addString(n+"="+t+";"):(this.vars[n]=!0,this.addString(e+" "+n+"="+t+";"))}},{key:"addSection",value:function(e){e in this._sections||(this._sections[e]=[]),this._sections.main.push(this._sections[e])}},{key:"addTag",value:function(n,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"main",o=this._sections[r];void 0===o&&(o=this._sections[r]=[]),e.addLiteral(o,n,t)}},{key:"addString",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"main",t=this._sections[n];void 0===t&&(t=this._sections[n]=[]),t.push(e),t.push("\n")}},{key:"addUniform",value:function(e){this.uniforms[e.name]=e}},{key:"compile",value:function(){this.addSection("end");var e=[];if(!CK.Settings.webgl2)for(var n in this.extensions)e.push("#extension "+n+" : enable\n");for(var t in e.push(this.es3?"\n#version 300 es\nprecision highp float;\nprecision mediump int;\n":"\nprecision highp float;\nprecision highp int;\n"),this.uniforms){var r=this.uniforms[t],o=v[r.type];"define"===r.store?e.push("#define "+t+" "+u(r.value)+"\n"):"const"===r.store?e.push("const "+o+" "+t+"="+u(r.value)+";\n"):"dataTexture"===r.store||e.push("uniform ".concat(o," ").concat(t).concat(void 0!==r.count?"["+r.count+"]":"",";\n"))}var i=[],a=this._sections.main;for(var c in a){var s=a[c];Array.isArray(s)?i.push(s.join("")):i.push(s)}var l=e.concat(this._sections.parsStart,this._sections.pars,"\nvoid main(){\n",i,"}").join("");return this.es3&&(console.warn("Very hackily swapping to es3 (webgl2) shader syntax using string replace."),l=l.replace(/attribute /g,"in "),l=(l=(l=(l=this.isVertexShader?l.replace(/varying /g,"out "):l.replace(/varying /g,"in ")).replace(/gl_FragColor/g,"fragmentColor")).replace(/texture2D/g,"texture")).replace(/textureCube/g,"texture")),l}}])&&f(n.prototype,t),r&&f(n,r),e}(),v={i:"int",f:"float",v2:"vec2",v3:"vec3",t:"sampler2D",m4:"mat4",m3:"mat3",v4:"vec4",v4v:"vec4"};function d(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function h(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var m=function(){function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;d(this,e),this.shaderName=r,this.options=t,this.debugVars=[],this._generators={},this.uniforms={},this._vertex=new p(!0,this.options.es3&&CK.Settings.webgl2),this._fragment=new p(!1,this.options.es3&&CK.Settings.webgl2),this._codeRegister={},this.p=function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),o=1;o<t;o++)r[o-1]=arguments[o];n._vertex.addTag(e,r,"pars"),n._fragment.addTag(e,r,"pars")},this.u=function(e){n._vertex.addUniform(e),n._fragment.addUniform(e)},this.add=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{id:1};for(var r in t.id=t.id||1,"function"==typeof e&&(e=[e]),e)e[r](n,n._vertex.m,n._fragment.m,t)},this.debugVert=function(){},this.debugFrag=function(){},this.debug=function(){},this.f=this._fragment.m,this.v=this._vertex.m,this.v.debug=function(e){n.debugVert(e,void 0,!0),t.debugVertNow=!0},this.section=function(e,t){n._vertex.m.s(e,t),n._fragment.m.s(e,t)},this.register=function(e){e in n._codeRegister||(n._codeRegister[e]=0);var t=n._codeRegister[e];return n._codeRegister[e]++,t}}var n,t,r;return n=e,(t=[{key:"buildVertex",value:function(){return this._vertex.compile()}},{key:"buildFragment",value:function(){return this._fragment.compile()}},{key:"buildUniforms",value:function(){return Object.assign(this.uniforms,this._fragment.uniforms,this._vertex.uniforms)}},{key:"build",value:function(){return{fragment:this._fragment.compile(),vertex:this._vertex.compile(),uniforms:this.buildUniforms(),debugVars:this.debugVars}}}])&&h(n.prototype,t),r&&h(n,r),e}();function g(){var e=w(["out vec4 fragmentColor;"]);return g=function(){return e},e}function y(){var e=w(["#define PI 3.14159265359\n        #define PI2 6.28318530718\n        #define RECIPROCAL_PI 0.31830988618\n        #define RECIPROCAL_PI2 0.15915494\n        #define LOG2 1.442695\n        #define EPSILON 1e-6\n        \n        #define saturate(a) clamp( a, 0.0, 1.0 )\n        #define whiteCompliment(a) ( 1.0 - saturate( a ) )\n        #define round(a) floor(a + 0.5)\n        \n        float pow2( const in float x ) { return x*x; }\n        float pow3( const in float x ) { return x*x*x; }\n        float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\n        float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n        \n        ","\n        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n        \n            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n        \n        }\n        \n        float MinComponent( vec2 v ){ return min( v.x, v.y ); }\n        \n        float MinComponent( vec3 v ){ return min( min( v.x, v.y ), v.z ); }\n        \n        float MinComponent( vec4 v ){ return min( min( min( v.x, v.y ), v.z ), v.w ); }\n\n        ","\n        mat3 RotateX(float angle)\n         {\n            float c = cos(angle);\n            float s = sin(angle);\n            return mat3(\n                1.0,  0.0, 0.0,\n                0.0,  c,   s,\n                0.0, -s,   c\n            );\n        }\n\n        ","\n        mat3 RotateY(float angle)\n         {\n            float c = cos(angle);\n            float s = sin(angle);\n            return mat3(\n                c,    0.0, -s,\n                0.0,  1.0,  0.0,\n                s,    0.0,  c\n            );\n        }\n\n        #define FLOAT_MAX  1.70141184e38\n        #define FLOAT_MIN  1.17549435e-38\n\n        ","\n        vec4 PackFractVec4(float value)\n        {\n            ","\n            value = clamp(value, 0.0, 1.0);\n            ","\n            value *= (256.0 * 256.0 * 256.0 - 1.0);\n            ","\n            vec4 result;\n            result.r = floor(value / (256.0 * 256.0));\n            result.g = floor(mod(value / 256.0, 256.0));\n            result.b = floor(mod(value, 256.0));\n            result.a = 255.0; ","\n            result /= 255.0;\n            return result;\n        }\n\n        float UnpackFractVec4(vec4 value)\n        {\n            ","\n            value *= 255.0;\n            ","\n            float result \n                = value.r * 256.0 * 256.0\n                + value.g * 256.0\n                + value.b;\n            ","\n            result /= (256.0 * 256.0 * 256.0 - 1.0);\n            return result;\n        }\n\n        ","\n        lowp vec4 PackFloat32(highp float v)\n        {\n            highp vec4 result = vec4(0, 0, 0, 0);\n\n            highp float av = abs(v);\n            \n            ","\n            if (av < FLOAT_MIN)\n            {\n                result = vec4(0.0, 0.0, 0.0, 0.0);\n            }\n            else if (v > FLOAT_MAX)\n            {\n                result = vec4(127.0, 128.0, 0.0, 0.0) / 255.0;\n            }\n            else if (v < -FLOAT_MAX)\n            {\n                result = vec4(255.0, 128.0, 0.0, 0.0) / 255.0;\n            }\n            else\n            {\n                highp vec4 c = vec4(0,0,0,0);\n                \n                ","\n                highp float e = floor(log2(av));\n                highp float m = av * pow(2.0, -e) - 1.0;\n                \n                ","\n                c[1] = floor(128.0 * m);\n                m -= c[1] / 128.0;\n                c[2] = floor(32768.0 * m);\n                m -= c[2] / 32768.0;\n                c[3] = floor(8388608.0 * m);\n                \n                ","\n                highp float ebias = e + 127.0;\n                c[0] = floor(ebias / 2.0);\n                ebias -= c[0] * 2.0;\n                c[1] += floor(ebias) * 128.0; \n                \n                ","\n                c[0] += 128.0 * step(0.0, -v);\n                \n                ","\n                result = c / 255.0;\n            }\n            return result;\n        }\n\n        ","\n        highp float UnpackFloat32(lowp vec4 packedFloat)\n        {\n            highp float result = 0.0;\n\n            ","\n            highp vec4 c = packedFloat;\n            c *= 255.0;\n\n            ","\n            if (dot(c, c) < 0.5)\n            {\n                result = 0.0;\n            }\n            else\n            {\n                ","\n                highp float sign = step(1.0, c[0] / 128.0) * -2.0 + 1.0;\n\n                ","\n                highp float biasedExponent \n                    = mod(c[0], 128.0) * 2.0\n                    + c[1] / 128.0;\n                highp float exponent = biasedExponent - 127.0;\n\n                ","\n                highp float significand \n                    = 1.0\n                    + mod(c[1], 128.0) / 128.0\n                    + c[2] / 32768.0\n                    + c[3] / 8388608.0;\n\n                ","\n                result = sign * significand * pow(2.0, exponent);\n            }\n\n            return result;\n        }\n\n        #define FLOAT16_MIN 6.10352e-5\n        #define FLOAT16_MAX 3.2767e4\n\n        ","\n        lowp vec2 PackFloat16(highp float value)\n        {\n            highp vec2 result = vec2(0, 0);\n\n            highp float absValue = abs(value);\n            \n            ","\n            if (absValue < FLOAT16_MIN)\n            {\n                result = vec2(0.0, 0.0);\n            }\n            else if (absValue > FLOAT16_MAX)\n            {\n                result = vec2(124.0, 0.0) / 255.0;\n            }\n            else if (absValue < -FLOAT16_MAX)\n            {\n                result = vec2(252.0, 0.0) / 255.0;\n            }\n            else\n            {\n                highp vec2 c = vec2(0, 0);\n                \n                ","\n                highp float exponent = floor(log2(absValue));\n                highp float significand = absValue * pow(2.0, -exponent) - 1.0;\n                \n                ","\n                highp float bit15 = step(0.0, -value);\n                c[1] += 128.0 * bit15;\n\n                ","\n                highp float biasedExponent = exponent + 15.0;\n                highp float bits10_14 = floor(biasedExponent);\n                c[1] += bits10_14 * 4.0;\n\n                ","\n                highp float bits8_9 = floor(4.0 * significand);\n                c[1] += bits8_9;\n                significand -= bits8_9 / 4.0;\n                highp float bits0_7 = floor(1024.0 * significand);\n                c[0] += bits0_7;\n                                        \n                ","\n                result = c / 255.0;\n            }\n            return result;\n        }\n\n        ","\n        highp float UnpackFloat16(lowp vec2 packedFloat)\n        {\n            highp float result = 0.0;\n\n            ","\n            highp vec2 c = packedFloat;\n            c *= 255.0;\n\n            ","\n            if (dot(c, c) < 0.5)\n            {\n                result = 0.0;\n            }\n            else\n            {\n                ","\n                highp float sign = step(1.0, c[1] / 128.0) * -2.0 + 1.0;\n\n                ","\n                highp float biasedExponent \n                    = mod(c[1], 128.0) / 4.0;\n                highp float exponent = biasedExponent - 15.0;\n\n                ","\n                highp float significand \n                    = 1.0\n                    + mod(c[1], 4.0) / 4.0\n                    + c[0] / 1024.0;\n\n                ","\n                result = sign * significand * pow(2.0, exponent);\n            }\n            return result;\n        }\n\n        ","\n        lowp vec2 PackUint16(highp float value)\n        {\n            highp float maxUint16 = 65535.0;\n            value = clamp(value, 0.0, maxUint16);\n            highp float byte1 = floor(value / 256.0);\n            highp float byte0 = floor(value - byte1 * 256.0);\n            highp vec2 packedUInt16 = vec2(byte0, byte1) / 255.0;\n            return packedUInt16;\n        }\n\n        ","\n        highp float UnpackUint16(lowp vec2 value)\n        {\n            highp float byte0 = value.x;\n            highp float byte1 = value.y;\n            highp float asUint16 = (byte0 + byte1 * 256.0) * 255.0;\n            return asUint16;\n        }\n\n        ","\n        lowp vec2 PackUint16Unorm(highp float value)\n        {\n            highp float maxUint16 = 65535.0;\n            highp float asUint16 = value * maxUint16;\n            asUint16 = clamp(asUint16, 0.0, maxUint16);\n            highp float byte1 = floor(asUint16 / 256.0);\n            highp float byte0 = floor(asUint16 - byte1 * 256.0);\n            highp vec2 packedUInt16 = vec2(byte0, byte1) / 255.0;\n            return packedUInt16;\n        }\n\n        ","\n        highp float UnpackUint16Unorm(lowp vec2 value)\n        {\n            highp float byte0 = value.x;\n            highp float byte1 = value.y;\n            highp float asUint16 = (byte0 + byte1 * 256.0) * 255.0;\n            highp float maxUint16 = 65535.0;\n            return asUint16 / maxUint16;\n        }\n\n        float SrgbToLinear(float x)\n        {\n            float result = 0.0;\n            if (x < 0.04045)\n            {\n                result = x / 12.92;\n            }\n            else\n            {\n                result = pow(abs((x + 0.055)/1.055), 2.4);\n            }\n            return result;\n        }\n\n        vec3 SrgbToLinear(vec3 srgb)\n        {\n            return vec3(\n                SrgbToLinear(srgb.r),\n                SrgbToLinear(srgb.g),\n                SrgbToLinear(srgb.b));\n        }\n        \n        vec4 SrgbToLinear(vec4 srgb)\n        {\n            return vec4(\n                SrgbToLinear(srgb.r),\n                SrgbToLinear(srgb.g),\n                SrgbToLinear(srgb.b),\n                srgb.a\n            );\n        }\n\n        float LinearToSrgb(float x)\n        {\n            float result = 0.0;\n            if (x <= 0.0031308)\n            {\n                result = 12.92 * x;\n            }\n            else\n            {\n                result = 1.055*pow(abs(x),(1.0 / 2.4) ) - 0.055;\n            }\n            return result;\n        }\n\n        vec3 LinearToSrgb(vec3 linear)\n        {\n            return vec3(\n                LinearToSrgb(linear.r),\n                LinearToSrgb(linear.g),\n                LinearToSrgb(linear.b));\n        }\n\n        uniform mat4 viewMatrix;\n        uniform vec3 cameraPosition;\n        varying vec3 vViewPosition; "]);return y=function(){return e},e}function b(){var e=w(["attribute vec3 position;\n        uniform mat4 modelMatrix;\n        uniform mat4 modelViewMatrix;\n        uniform mat4 projectionMatrix;\n        uniform mat3 normalMatrix; "]);return b=function(){return e},e}function w(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function x(e,n,t){n.p(b()),e.p(y(),"","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""),e.options.es3&&t.p(g()),t.extension("GL_OES_standard_derivatives")}function S(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["if( ",".y < "," )",".y = ",";"]);return S=function(){return e},e}function O(e,n,t){if(void 0!==e.options.clipHeight){var r=""+e.options.clipHeight.toFixed(5),o=e.options.skinning?"skinned":"transformed";n(S(),o,r,o,r)}}function L(){var e=F(["\n        gl_Position = projectionMatrix * mvPosition; \n        vViewPosition = - mvPosition.xyz;"]);return L=function(){return e},e}function _(){var e=F(["vObjectPosition = transformed;"]);return _=function(){return e},e}function D(){var e=F(["\n            vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n            vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n            \n        "]);return D=function(){return e},e}function P(){var e=F(["vObjectPosition = skinned.xyz;"]);return P=function(){return e},e}function k(){var e=F(["\n            vec4 mvPosition = modelViewMatrix * skinned;\n            vec4 worldPosition = modelMatrix * skinned;\n        "]);return k=function(){return e},e}function C(){var e=F(["\n            skinned /= skinWeightSum;\n            skinned.w = 1.0;\n            skinned  = bindMatrixInverse * skinned;\n            "]);return C=function(){return e},e}function M(){var e=F(["\n                mat4 boneMat"," = getBoneMatrix(skinIndex",".",");\n                skinned += boneMat"," * skinVertex * skinWeight",".",";\n                skinWeightSum += skinWeight",".",";\n                "]);return M=function(){return e},e}function R(){var e=F(["\n\n            vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n            vec4 skinned = vec4( 0.0 );\n            float skinWeightSum = 0.0;\n            "]);return R=function(){return e},e}function T(){var e=F(["return mat4( v1, v2, v3, v4 ); }"]);return T=function(){return e},e}function z(){var e=F(["vec4 v"," = vec4( \n                    DecodeFloatRGBA( texture2D( boneTexture, vec2( boneTextureDX * ( ",".0 + x + 0.5 ), y ) ) ),\n                    DecodeFloatRGBA( texture2D( boneTexture, vec2( boneTextureDX * ( ",".0 + x + 1.5 ), y ) ) ),\n                    DecodeFloatRGBA( texture2D( boneTexture, vec2( boneTextureDX * ( ",".0 + x + 2.5 ), y ) ) ),\n                    DecodeFloatRGBA( texture2D( boneTexture, vec2( boneTextureDX * ( ",".0 + x + 3.5 ), y ) ) )\n                );"]);return z=function(){return e},e}function j(){var e=F(["\n              \n            float DecodeFloatRGBA( vec4 rgba ){\n                rgba = round( rgba * 255.0 );\n                return rgba.r - 128.0 + ( rgba.g * "," + rgba.b * "," + rgba.a * "," ) ;\n            }\n            \n            mat4 getBoneMatrix( const in float i ) {\n                float j = i * 16.0;\n                float x = mod( j, float( boneTextureWidth ) );\n                float y = floor( j / float( boneTextureWidth ) );\n            \n                y = boneTextureDY * ( y + 0.5 );\n\n            "]);return j=function(){return e},e}function U(){var e=F(["\n            mat4 getBoneMatrix( const in float i ) {\n                float j = i * 4.0;\n                float x = mod( j, float( boneTextureWidth ) );\n                float y = floor( j / float( boneTextureWidth ) );\n            \n                y = boneTextureDY * ( y + 0.5 );\n            \n                vec4 c1 = texture2D( boneTexture, vec2( boneTextureDX * ( x + 0.5 ), y ) );\n                vec4 c2 = texture2D( boneTexture, vec2( boneTextureDX * ( x + 1.5 ), y ) );\n                vec4 c3 = texture2D( boneTexture, vec2( boneTextureDX * ( x + 2.5 ), y ) );\n                vec4 v1 = vec4(c1.x, c2.x, c3.x, 0.0);\n                vec4 v2 = vec4(c1.y, c2.y, c3.y, 0.0);\n                vec4 v3 = vec4(c1.z, c2.z, c3.z, 0.0);\n                vec4 v4 = vec4(c1.w, c2.w, c3.w, 1.0);\n            \n                return mat4( v1, v2, v3, v4 );\n            }"]);return U=function(){return e},e}function V(){var e=F(["\n            attribute vec4 skinIndex",";\n            attribute vec4 skinWeight",";\n        "]);return V=function(){return e},e}function N(){var e=F(["\n            uniform mat4 bindMatrix;\n            uniform mat4 bindMatrixInverse;\n            \n            uniform sampler2D boneTexture;\n            #define boneTextureWidth ","\n            #define boneTextureHeight ","\n            #define boneTextureDX ","\n            #define boneTextureDY ","\n        "]);return N=function(){return e},e}function I(){var e=F(["varying vec3 vObjectPosition;"]);return I=function(){return e},e}function F(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function E(e,n,t){n.s("start","vec3 transformed = vec3( position );");var r=e.options.skinIncludeObjectPosition||e.options.volumeFieldNormal;if(r&&e.p(I()),e.options.skinning){var o=CK.ClientSpecs.check("OES_texture_float")||CK.Settings.webgl2,i=o?64:128;n.p(N(),i,i,a(1/i,15),a(1/i,15));for(var c=e.options.skinInfluenceCount||4,u=Math.ceil(c/4),s=0;s<u;++s)n.p(V(),s,s);if(o)n.p(U());else{n.p(j(),a(1/16777215,10),a(256/16777215,10),a(65536/16777215,10));for(var l=0;l<4;l++)n.p(z(),l+1,4*l,4*l,4*l,4*l);n.p(T())}n(R());for(var f=["x","y","z","w"],p=0;p<c;++p){var v=Math.floor(p/4),d=f[p%4];n(M(),p,v,d,p,v,d,v,d)}n(C()),e.add(O),n(k()),r&&n(P())}else n(D()),r&&n(_());n(L())}function A(){var e=G(["vUv"," = uv",";"]);return A=function(){return e},e}function B(){var e=G(["attribute vec2 uv",";"]);return B=function(){return e},e}function K(){var e=G(["varying vec2 vUv",";"]);return K=function(){return e},e}function G(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function W(e,n,t){function r(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";e.p(K(),t),n.p(B(),t),n(A(),t,t),e.debugVert("uv".concat(t),"vec3(uv".concat(t,", 0.0)"))}e.options.uv&&r(),e.options.uv2&&r("2")}function H(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}E.n="skin";var X=function(){function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)}var n,t,r;return n=e,r=[{key:"makeTexture",value:function(e,n){var t=e.join(",")+(n?n.join(","):"");return t in this._cached||(this._cached[t]=this._makeTexture(e)),this._cached[t]}},{key:"_makeTexture",value:function(e){for(var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1],t=new Uint8Array(4*n[0]*n[1]),r=0;r<n[0]*n[1];r++)for(var o=0;o<4;o++)t[4*r+o]=Math.min(Math.max(255*e[o],0),255);var i=new RK.DataTexture(t,1,1,RK.RGBAFormat,RK.UnsignedByteType);return i.needsUpdate=!0,i.shared=!0,i}},{key:"normal",get:function(){return this.makeTexture([.5,.5,1,1])}},{key:"gray",get:function(){return this.makeTexture([.5,.5,.5,1])}},{key:"transparentBlack",get:function(){return this.makeTexture([0,0,0,0])}},{key:"black",get:function(){return this.makeTexture([0,0,0,1])}},{key:"defaultIris",get:function(){if(void 0===this._defaultIris){for(var e=new Uint8Array(262144),n=0;n<256;++n)for(var t=(n+.5)/256*2-1,r=0;r<256;++r){var o=256*n+r,i=(r+.5)/256*2-1,a=Math.sqrt(i*i+t*t),c=0;a<.2?c=1:a<1&&(c=.5);var u=(a-.2)/.8;u=Math.min(Math.max(u,0),1);for(var s=0;s<3;++s)e[4*o+s]=255*u;e[4*o+3]=255*c}var l=new RK.DataTexture(e,256,256,RK.RGBAFormat,RK.UnsignedByteType);l.needsUpdate=!0,l.shared=!0,this._defaultIris=l}return this._defaultIris}}],(t=null)&&H(n.prototype,t),r&&H(n,r),e}();function Y(){var e=Z(["\n        layerUvs = vUv;\n        ","\n\n        if( ","_tiling == 0 ){\n\n            if( layerUvs.x - ","_udimID >= 0.0 && layerUvs.x - ","_udimID <= 1.0 )inUdim = 1.0;\n            else inUdim = 0.0;\n\n            layerUvs.x -= ","_udimID;\n\n            layerUvs = vec2( layerUvs.x / ","_uvOffset.z - ","_uvOffset.x / ","_uvOffset.z , layerUvs.y / ","_uvOffset.w - ","_uvOffset.y / ","_uvOffset.w );\n\n            inLayerBounds = saturate ( ( min( MinComponent( 1.0 - saturate(layerUvs) ),MinComponent( saturate( layerUvs ) ) ) - 0.01 ) * 1.0/0.1 ) * inUdim;\n\n        } else {\n            layerUvs = layerUvs * ","_uvOffset.zw;\n            inLayerBounds = 1.0;\n        }\n\n        inPatch = 0.0;\n        for( int id = 0; id < 26; id++ ){\n            inPatch = max( inPatch, float( ","_patches[id]  ) * ( id == rID ? 1.0 - aaID.b : id == gID ? aaID.b : 0.0 ) );\n        }\n        inLayerBounds *= inPatch;\n\n        if( inLayerBounds > 0.004 ){\n            if( ","_form <= 2 ){\n\n                if( ","_form == 2 ){ //color\n\n                    colorValue = ",";\n                    masksValue = vec4(0.0,0.0,0.0,0.0);\n\n                } else { //masks\n\n                    masksValue = texture2D( ","_map, layerUvs );\n                    colorValue = vec4(0.0,0.0,0.0,0.0);\n\n\n                }\n\n            } else if ( ","_form == 3 ){ //both color and masks\n\n                colorValue = ",";\n                masksValue = texture2D( ","_map, vec2(layerUvs.x / 2.0 + 0.5,layerUvs.y) );\n\n            }\n\n        } else inLayerBounds = 0.0;\n\n        masksValue *= inLayerBounds;\n        colorValue.a *= inLayerBounds;\n\n    "]);return Y=function(){return e},e}function q(){var e=Z(["\n            vec2 layerUvs;\n            vec2 colorUVs;\n            vec2 masksUVs;\n            vec4 colorValue;\n            vec4 masksValue;\n            vec4 layerTextureValue;\n            float inLayerBounds;\n            float inPatch;\n            float inUdim;\n            int rID = int( floor(aaID.r * 255.0 + 0.5 ) );\n            int gID = int( floor(aaID.g * 255.0 + 0.5 ) );\n        "]);return q=function(){return e},e}function Z(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Q(e,n,t,r){var o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];e.hasAddedSimpleLayered||(e.hasAddedSimpleLayered=!0,t(q()));var i="l"+r;t.u({name:i+"_map",type:"t",value:X.transparentBlack}),t.u({name:i+"_patches",type:"i",value:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],count:26}),t.u({name:i+"_uvOffset",type:"v4",value:new RK.Vec4(0,0,1,1)}),t.u({name:i+"_form",type:"i",value:1}),t.u({name:i+"_uvSet2",type:"i",value:0}),t.u({name:i+"_tiling",type:"i",value:0}),t.u({name:i+"_colorIndex",type:"i",value:0}),t.u({name:i+"_udimID",type:"f",value:0}),t(Y(),e.options.uv2?"if( ".concat(i,"_uvSet2 == 1 )layerUvs = vUv2;"):"",i,i,i,i,i,i,i,i,i,i,i,i,i,i,o?"vec4(0.0,0.0,0.0,0.0)":"texture2D( ".concat(i,"_map, layerUvs )"),i,i,o?"vec4(0.0,0.0,0.0,0.0)":"texture2D( ".concat(i,"_map, vec2(layerUvs.x / 2.0,layerUvs.y) )"),i)}function J(){var e=oe(["if(diffuseColor.a < 0.004 )diffuseColor.a = 0.004;"]);return J=function(){return e},e}function $(){var e=oe(["\n\n            if( idInfluences[","] > 0.0 ){\n                gradientMapV = ( ids[","] / patchCount ) + ( 0.5 / patchCount );\n\n                wash = texture2D( gradientsMap, vec2( 1.0/8.0 , gradientMapV ) );\n\n                base = texture2D( gradientsMap, vec2( 3.0/8.0 , gradientMapV ) );\n\n                highlight = texture2D( gradientsMap, vec2( 5.0/8.0 , gradientMapV ) );\n\n                special = texture2D( gradientsMap, vec2( 7.0/8.0 , gradientMapV ) );\n\n\n                ","\n\n                diffuseColor += color * idInfluences[","];\n\n            }\n\n        "]);return $=function(){return e},e}function ee(){var e=oe(["\n        layerMaskType = 0.0;\n        layerInfluence = aaID.b * lightLeft;\n        if( lightLeft > 0.0 && layerInfluence > 0.0 ){\n\n            ","\n            lightLeft -= layerInfluence;\n        }\n\n        layerInfluence = lightLeft;\n        if( layerInfluence > 0.0 ){\n            ","\n        }\n\n        float gradientMapV;\n\n        vec4 wash, base, highlight, special, color;\n\n    "]);return ee=function(){return e},e}function ne(){var e=oe(["\n                if( "," >= l","_colorIndex && l","_colorIndex >= 0 ){ //stuff above this layer needs a special type of mask\n                    layerMaskType = 1.0 + mix( maskSimple, (colorValue.r + colorValue.g + colorValue.b) / 3.0, colorValue.a );\n                } else {\n                    layerMaskType = 0.0;\n                }\n\n                layerInfluence = lightLeft * masksValue[","];\n\n                if( lightLeft > 0.0 && layerInfluence > 0.0 ){\n\n                    ","\n\n                    lightLeft -= layerInfluence;\n\n                }\n\n                if( "," == l","_colorIndex ){\n                    diffuseColor += vec4( colorValue.rgb * colorValue.a * lightLeft, 1.0 );\n                    lightLeft -= colorValue.a;\n                }\n            "]);return ne=function(){return e},e}function te(){var e=oe(["\n\n        float lightLeft = 1.0;\n\n        vec4 ids = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec4 idInfluences = vec4( 0.0, 0.0, 0.0, 0.0 );\n        vec4 idMaskTypes = vec4( 0.0, 0.0, 0.0, 0.0 ); //0 is regular mask, 1+ is a color decal mask for color overlaying it's own decal.\n\n        float layerInfluence = 0.0;\n\n        vec3 aaID = texture2D( aaidMap, vUv ).rgb;\n        vec3 masks = texture2D( masksMap, vUv ).rgb;\n\n        float maskSimple = mix( mix( 0.5, 0.0, masks.g ), 1.0, masks.r );\n\n        float layerMaskType;\n        diffuseColor = vec4(0.0,0.0,0.0,0.0);\n    "]);return te=function(){return e},e}function re(){var e=oe(["\n        vec4 miniPaint( vec4 wash, vec4 base, vec4 highlight, vec4 special, vec3 masks ){\n            return mix( mix( mix( base, wash, masks.g ), highlight, masks.r ), special, masks.b * special.a);\n        }\n\n        vec3 splitSimpleMask( float v ){\n            return vec3( v > 0.5 ? (v - 0.5) * 2.0 : 0.0, v <= 0.5 ? (0.5 - v) * 2.0 : 0.0, 0.0 );\n        }\n        \n        float blendOverlay(float base, float blend) {\n            return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n        }\n    \n        vec4 blendOverlay(vec3 base, vec3 blend) {\n            return vec4(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b), 1.0);\n        }\n    \n    "]);return re=function(){return e},e}function oe(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function ie(e){return"\n        if( layerInfluence > idInfluences.x ){\n\n            idInfluences.yzw = idInfluences.xyz;\n            ids.yzw = ids.xyz;\n            idMaskTypes.yzw = idMaskTypes.xyz;\n\n            idInfluences.x = layerInfluence;\n            ids.x = ".concat(e,";\n            idMaskTypes.x = layerMaskType;\n\n        } else if ( layerInfluence > idInfluences.y ){\n\n            idInfluences.zw = idInfluences.yz;\n            ids.zw = ids.yz;\n            idMaskTypes.zw = idMaskTypes.yz;\n\n            idInfluences.y = layerInfluence;\n            ids.y = ").concat(e,";\n            idMaskTypes.y = layerMaskType;\n\n        } else if ( layerInfluence > idInfluences.z ){\n\n            idInfluences.w = idInfluences.z;\n            ids.w = ids.z;\n            idMaskTypes.w = idMaskTypes.z;\n\n            idInfluences.z = layerInfluence;\n            ids.z = ").concat(e,";\n            idMaskTypes.z = layerMaskType;\n\n        } else if ( layerInfluence > idInfluences.w ){\n\n            idInfluences.w = layerInfluence;\n            ids.w = ").concat(e,";\n            idMaskTypes.w = layerMaskType;\n\n        }\n    ")}function ae(e,n,t){t.p(re()),t.u({name:"gradientsMap",type:"t",value:X.gray}),t.u({name:"masksMap",type:"t",value:X.gray}),t.u({name:"aaidMap",type:"t",value:X.transparentBlack}),t.u({name:"patchCount",type:"f",value:26}),t(te());for(var r=e.options.layerCount-1;r>=0;r--){Q(e,n,t,r);for(var o=3;o>=0;o--){var i=SK.float(4*e.options.layerCount-(4*r+o));t(ne(),o,+r,+r,o,ie("(patchCount - ".concat(i,")")),o,+r)}}t(ee(),ie("floor( aaID.g * 255.0 + 0.5 )"),ie("floor( aaID.r * 255.0 + 0.5 )"));for(var a=0;a<4;a++)t($(),a,a,e.options.overlayOnColor?"color = idMaskTypes[".concat(a,"] < 0.5 ? miniPaint( wash, base, highlight, special, masks ) : blendOverlay( vec3( idMaskTypes[").concat(a,"] - 1.0 ), base.rgb );"):"color = miniPaint( wash, base, highlight, special, idMaskTypes[".concat(a,"] < 0.5 ? masks : splitSimpleMask( idMaskTypes[").concat(a,"] - 1.0 ) );"),a);t(J())}function ce(){var e=le(["gl_Position = vec4( ( vUv.xy * uvPosScl.z + uvPosScl.xy ) * 2.0 - 1.0, 0.0, 1.0 ); // -1 to 1 is the final space."]);return ce=function(){return e},e}function ue(){var e=le(["gl_Position = vec4( ( uv_seam.xy * uv_seamPosScl.z + uv_seamPosScl.xy ) * 2.0 - 1.0, uv_seam.z, 1.0 ) ; // -1 to 1 is the final space."]);return ue=function(){return e},e}function se(){var e=le(["attribute vec3 uv_seam;"]);return se=function(){return e},e}function le(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function fe(e,n,t){e.options.seamFin?(n.p(se()),n.u({name:"uv_seamPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),n(ue())):n(ce()),n.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.s("end","gl_FragColor = diffuseColor;")}function pe(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}X._cached={};var ve=function(){function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e)}var n,t,r;return n=e,r=[{key:"clone",value:function(e){var n={};for(var t in e)for(var r in n[t]={},e[t]){var o=e[t][r];o instanceof RK.Color||o instanceof RK.Vec2||o instanceof RK.Vec3||o instanceof RK.Vec4||o instanceof RK.Matrix3||o instanceof RK.Matrix4?n[t][r]=o.clone():o instanceof RK.Texture?n[t][r]=o:Array.isArray(o)?n[t][r]=o.slice():n[t][r]=o}return n}}],(t=null)&&pe(n.prototype,t),r&&pe(n,r),e}();function de(e){return(de="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function he(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function me(e,n){return!n||"object"!==de(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ge(e){return(ge=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function ye(e,n){return(ye=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var be=function(e){function n(){var e;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(e=me(this,ge(n).call(this))).uniforms={},e.blindlySetUniforms={},e.name="Material"+e.id,e.cachable=!0,e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&ye(e,n)}(n,RK.RawShaderMaterial),t=n,o=[{key:"sameOption",value:function(e,t){if(void 0===e&&void 0!==t)return!1;if(void 0!==e&&void 0===t)return!1;if("object"===de(e)){if(void 0!==e.toArray&&(e=e.toArray()),void 0!==t.toArray&&(t=t.toArray()),void 0===t||t.length!==e.length)return!1;for(var r in e)if(!n.sameOption(e[r],t[r]))return!1}else if(e!==t)return!1;return!0}}],(r=[{key:"init",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};for(var a in r)a in t||delete r[a];this.options=Object.assign({shaderName:this.constructor.name},t,r,o);var c=function(n){if(void 0===i[n]||!(n in e.options))return"continue";e.options[n]=!0,"object"===de(i[n])?e.uniforms[n]={type:"t",value:i[n]}:CK.Resources.getResource(i[n],void 0,e.name).then((function(t){!t&&n.startsWith("normal")&&(console.error("Missing normal map!",i[n]),t=X.normal),e.uniforms[n]={type:"t",value:t},t.wrapS=RK.RepeatWrapping,t.wrapT=RK.RepeatWrapping,CK.GameLoop.requestRenderRefresh()}))};for(var u in i)c(u);var s=function(t){Object.defineProperty(e,t,{get:function(){return e.options[t]},set:function(r){n.sameOption(e.options[t],r)||(e.needsRebuild=!0,e.options[t]=r)}})};for(var l in this.options)s(l);this.needsRebuild=!0}},{key:"rebuild",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.needsRebuild||t){var r;for(var o in this.needsRebuild=!1,this.hash=this.cachable?JSON.stringify(this.options):"UniqueMaterial_"+n.uniqueCount++,this.cachable?void 0===(r=n.cache[this.hash])&&(r=n.cache[this.hash]=this.makeShader().build()):r=this.makeShader().build(),this.shaderInfo=r,this.uniforms=Object.assign(ve.clone(r.uniforms),this.uniforms),this.debugVars=r.debugVars,this.blindlySetUniforms)o in this.uniforms&&(this.uniforms[o].value=this.blindlySetUniforms[o],delete this.blindlySetUniforms[o]);CK.Settings.debug&&Object.keys(this.blindlySetUniforms).length>0&&console.log("Debug - The built shader never used these uniforms",this.blindlySetUniforms);var i=function(n){n in e||Object.defineProperty(e,n,{get:function(){return e.uniforms[n].value},set:function(t){e.uniforms[n].value=t}})};for(var a in this.uniforms)i(a);this.shader={name:this.type,uniforms:this.uniforms},Object.defineProperty(this.shader,"vertexShader",{get:function(){return e.shaderInfo.vertex}}),Object.defineProperty(this.shader,"fragmentShader",{get:function(){return e.shaderInfo.fragment}}),this.needsUpdate=!0}}},{key:"getUniform",value:function(e){var n=void 0;return e in this.blindlySetUniforms&&(n=this.blindlySetUniforms[e]),e in this.uniforms&&(n=this.uniforms[e].value),n}},{key:"getUniforms",value:function(){var e={};for(var n in this.blindlySetUniforms)e[n]=this.blindlySetUniforms[n];for(var t in this.uniforms)e[t]=this.uniforms[t].value;return e}},{key:"setUniform",value:function(e,n){e in this.uniforms?this.uniforms[e].value=n:this.blindlySetUniforms[e]=n}},{key:"setUniforms",value:function(e){for(var n in e)this.setUniform(n,e[n])}},{key:"makeShader",value:function(){console.warn("Material makeShader() function needs to be overwritten")}},{key:"dispose",value:function(){CK.Resources.unregister(this.name)}},{key:"debugPrintFragShader",value:function(){this.rebuild(),console.log(this.fragmentShader)}},{key:"debugPrintVertShader",value:function(){this.rebuild(),console.log(this.vertexShader)}}])&&he(t.prototype,r),o&&he(t,o),n}();function we(e){return(we="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function xe(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec4 diffuseColor;"]);return xe=function(){return e},e}function Se(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Oe(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Le(e,n){return!n||"object"!==we(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function _e(e){return(_e=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function De(e,n){return(De=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}be.cache={},be.uniqueCount=0;var Pe=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Se(this,n),(e=Le(this,_e(n).call(this))).init({bake:!0,uv:!0,uv2:!0,colorLayers:!1,normalLayers:!1,physicalLayers:!1,depthLayers:!1,emissiveLayers:!1,occlusionTextureSize:2048,seamFin:!1,layerCount:0,overlayOnColor:!1},t.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1}),e.transparent=!1,e.lights=!1,e.depthWrite=!1,e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&De(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"BakeLayers");return e.f(xe()),e.add([x,W,E,ae,fe]),e}},{key:"setAAID",value:function(e){e.magFilter=RK.NearestFilter,e.minFilter=RK.NearestFilter,e.generateMipmaps=!1,this.setUniform("aaidMap",e)}},{key:"setPatchCount",value:function(e,n){n>5&&(n=console.error("Patch layer count exceeded max of 5")||5),this.basePatchCount=e;var t=this.basePatchCount+4*n;this.layerCount=n,this.gradientsMap&&this.gradientsMap.image.height===t||(this.gradientsMap=new RK.DataTexture(new Uint8Array(4*t*4),4,t,RK.RGBAFormat,RK.UnsignedByteType),this.gradientsMap.magFilter=RK.NearestFilter,this.gradientsMap.minFilter=RK.NearestFilter,this.gradientsMap.generateMipmaps=!1,this.setUniform("gradientsMap",this.gradientsMap),this.setUniform("patchCount",t))}},{key:"setPatch",value:function(e,n){if(!n||n.length<4)return console.error("Bad gradient supplied to set patch",n,this);for(var t=this.gradientsMap.image.data,r=4*e*4,o=0,i=0;i<4;i++)for(var a=0;a<4;a++){var c=parseInt(n[i]&&a in n[i]?n[i][a]:255);isNaN(c)&&(c=console.error("Invalid patch values set",c,n)||0),c<0&&(c=0),c>255&&(c=255),t[r+o]!==c&&(this.gradientsMap.needsUpdate=!0,t[r+o]=c),o++}}},{key:"setLayer",value:function(e){var n=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:3,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:[],s=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,l=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,f="l"+r,p=t.length?[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]:[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];t.map((function(e){return p[e]=1})),e.wrapS=e.wrapT=a?RK.RepeatWrapping:RK.ClampToEdgeWrapping,this.setUniform(f+"_map",e),this.setUniform(f+"_patches",p),this.setUniform(f+"_uvOffset",o||new RK.Vec4(0,0,1,1)),this.setUniform(f+"_form",c),this.setUniform(f+"_uvSet2",i?1:0),this.setUniform(f+"_tiling",a?1:0),this.setUniform(f+"_colorIndex",s),this.setUniform(f+"_udimID",l),u.map((function(e,t){return n.setPatch(n.basePatchCount+4*r+t,e)}))}},{key:"getKey",value:function(){for(var e=[Array.from(this.gradientsMap.image.data).join(","),this.layerCount,this.getUniform("uvPosScl").toArray().join(",")],n=0;n<this.layerCount;n++){var t="l"+n;e.push(this.getUniform(t+"_map").uid+this.getUniform(t+"_patches").join(",")+this.getUniform(t+"_uvOffset").toArray().join(",")+this.getUniform(t+"_form")+this.getUniform(t+"_uvSet2")+this.getUniform(t+"_tiling")+this.getUniform(t+"_udimID"))}return e.join("-")}}])&&Oe(t.prototype,r),o&&Oe(t,o),n}(be);function ke(){var e=Re(["vColor.xyz = color.xyz;"]);return ke=function(){return e},e}function Ce(){var e=Re(["attribute vec3 color;"]);return Ce=function(){return e},e}function Me(){var e=Re(["varying vec3 vColor;"]);return Me=function(){return e},e}function Re(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Te(e,n,t){e.p(Me()),n.p(Ce()),n(ke()),e.debugFrag("vColor")}function ze(e,n,t){0}function je(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["\n        vec3 packNormalToRGB( const in vec3 normal ) {\n          return normalize( normal ) * 0.5 + 0.5;\n        }\n        \n        vec3 unpackRGBToNormal( const in vec3 rgb ) {\n          return 1.0 - 2.0 * rgb.xyz;\n        }\n        \n        \n        vec4 packDepthToRGBA( const in float value ) {\n            const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n            const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n            vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n            res -= res.xxyz * bit_mask;\n            return res;\n        }\n        float unpackRGBAToDepth( const in vec4 rgba ) {\n            const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n            return dot( rgba, bitSh );\n        }\n        \n        // NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n        \n        float viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n          return ( viewZ + near ) / ( near - far );\n        }\n        float OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n          return linearClipZ * ( near - far ) - near;\n        }\n        \n        float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n          return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n        }\n        float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n          return ( near * far ) / ( ( far - near ) * invClipZ - far );\n        }\n        \n        "]);return je=function(){return e},e}function Ue(e,n,t){t.p(je())}function Ve(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["gl_FragColor = packDepthToRGBA( gl_FragCoord.z );"]);return Ve=function(){return e},e}var Ne=function(e,n,t){e.add(Ue),t(Ve())};function Ie(){var e=Nn(["\n\n        struct DirectionalLight {\n            vec3 direction;\n            vec3 color;\n    \n            int shadow;\n            float shadowBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLight directionalLights[ "," ];\n\n    "]);return Ie=function(){return e},e}function Fe(){var e=Nn(["\n    }"]);return Fe=function(){return e},e}function Ee(){var e=Nn(["\n            indirectSpecular *= specularOcclusion;"]);return Ee=function(){return e},e}function Ae(){var e=Nn(["specularOcclusion = mix( occlusion, 1.0, specularOcclusion );"]);return Ae=function(){return e},e}function Be(){var e=Nn(["\n            float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n            ","\n            float specularOcclusion = computeSpecularOcclusion( dotNV, occlusion, materialSpecularRoughness );"]);return Be=function(){return e},e}function Ke(){var e=Nn(["occlusion = SrgbToLinear(occlusion);\n\n            indirectDiffuse *= occlusion;"]);return Ke=function(){return e},e}function Ge(){var e=Nn(["occlusion = mix( 1.0, occlusion, lightingScaleFactor );"]);return Ge=function(){return e},e}function We(){var e=Nn(["occlusion *= geometryPreBakedOcclusion;"]);return We=function(){return e},e}function He(){var e=Nn(["occlusion = min(geometryPreBakedOcclusion, occlusion);"]);return He=function(){return e},e}function Xe(){var e=Nn(["float occlusion = 1.0;"]);return Xe=function(){return e},e}function Ye(){var e=Nn(["float occlusion = 0.8;"]);return Ye=function(){return e},e}function qe(){var e=Nn(["float occlusion = mix( 1.0, occlusionFactor, occlusionStrength );"]);return qe=function(){return e},e}function Ze(){var e=Nn(["float occlusionFactor = texture2D( occlusionMap, vUv.xy * uvPosScl.z + uvPosScl.xy ).r;"]);return Ze=function(){return e},e}function Qe(){var e=Nn(["float occlusion = mix( 1.0, effectiveOccFactor, occlusionStrength );"]);return Qe=function(){return e},e}function Je(){var e=Nn(["if ( useDefault == 1 ) effectiveOccFactor = 1.0;"]);return Je=function(){return e},e}function $e(){var e=Nn(["float effectiveOccFactor = vOcclusionFactor;"]);return $e=function(){return e},e}function en(){var e=Nn(["vOcclusionFactor = occlusionFactor;"]);return en=function(){return e},e}function nn(){var e=Nn(["attribute float occlusionFactor;"]);return nn=function(){return e},e}function tn(){var e=Nn(["\n        #endif\n    "]);return tn=function(){return e},e}function rn(){var e=Nn(["\n            directLight.color *= lightingScaleFactor;\n\n            RE_Direct(\n                directLight.color,\n                directLight.direction,\n                geometryNormal,\n                geometryViewDir,\n                materialDiffuseColor,\n                materialSpecularColor,\n                materialSpecularRoughness,\n                materialSheen,\n                directDiffuse,\n                directSpecular,\n                indirectDiffuse,\n                indirectSpecular);\n            }"]);return rn=function(){return e},e}function on(){var e=Nn(["\n                    directLight.color *= shadow;"]);return on=function(){return e},e}function an(){var e=Nn(["\n                    directLight.color *= min( shadow, mix( 1.0, geometryPreBakedOcclusion, occlusionStrength) );"]);return an=function(){return e},e}function cn(){var e=Nn(["\n                bool shadowIsEnabled = all( bvec2( directionalLight.shadow, directLight.visible ) );\n                float shadow \n                    = shadowIsEnabled\n                    ? getShadow( directionalShadowMap[ "," ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ "," ] )\n                    : 1.0;\n                shadow = mix(1.0, shadow, shadowStrength);\n                "]);return cn=function(){return e},e}function un(){var e=Nn(["float sunOcclusion = texture2D( sunOcclusionMap, sunOccUv.xy * uvPosScl.z + uvPosScl.xy ).r;\n\t                sunOcclusion = mix(1.0, sunOcclusion, shadowStrength);\n                    directLight.color *= sunOcclusion;"]);return un=function(){return e},e}function sn(){var e=Nn(["vec2 sunOccUv = vUv2;"]);return sn=function(){return e},e}function ln(){var e=Nn(["vec2 sunOccUv = vUv;"]);return ln=function(){return e},e}function fn(){var e=Nn(["\n            {\n                directionalLight = directionalLights[ "," ];\n                vec3 directLightColor = vec3(0);\n                getDirectionalDirectLightIrradiance(\n                    directionalLight.color,\n                    directionalLight.direction,\n                    directLight.color,\n                    directLight.direction,\n                    directLight.visible);"]);return fn=function(){return e},e}function pn(){var e=Nn(["\n        #if defined( RE_Direct ) //probably can take this out.\n        \n            DirectionalLight directionalLight;"]);return pn=function(){return e},e}function vn(){var e=Nn(["\n        }\n"]);return vn=function(){return e},e}function dn(){var e=Nn(["\n            float envMapMaxMip = 4.0;\n            vec3 viewPerp = GetPerpendicular(-geometryViewDir);\n            vec3 reflectionNormal = SafeNormalize(geometryNormal + geometryViewDir * reflectionWrap, viewPerp);\n            vec3 reflectVec = reflect( -geometryViewDir, reflectionNormal );\n            float dotNv = abs(dot( geometryViewDir, geometryNormal ));\n            float meanDotNv = 0.637; // Cosine weighted mean dot(normal, view)\n            dotNv = mix(dotNv, meanDotNv, reflectionWrap);\n            vec3 envSpecularIrradiance = SampleEnvironmentLightSpecular( ",", ",", reflectVec, materialSpecularRoughness, envMapMaxMip );\n            vec3 envSpecularReflectance = SampleEnvironmentReflectance( ",", ",", dotNv, materialSpecularRoughness, materialSpecularColor );\n            indirectSpecular += envSpecularIrradiance * envSpecularReflectance;\n            vec3 envDiffuse = SampleEnvironmentLightDiffuse( ",", ",", geometryNormal );\n            indirectDiffuse += envDiffuse * materialDiffuseColor;\n\n            // Sheen lighting.\n            float envSheenRoughness = 0.75;\n            vec3 envSheenIrradiance = SampleEnvironmentLightSpecular( ",", ",", reflectVec, envSheenRoughness, envMapMaxMip );\n            float envSheenAmount = pow(1.0 - dotNv, 5.0) * (1.0 - reflectionWrap);\n            indirectSpecular += envSheenIrradiance * envSheenAmount * materialSheen;\n        "]);return dn=function(){return e},e}function hn(){var e=Nn(["EnvironmentLight diceHackLight;\n            diceHackLight.rgbScale = vec3(2, 2, 2);\n            diceHackLight.saturationScale = 0.0;\n            diceHackLight.rotateY = 0.0;\n            diceHackLight.mapWidth = 512.0;\n            "]);return hn=function(){return e},e}function mn(){var e=Nn(["\n            for ( int i = 0; i < ","; i ++ ) {\n"]);return mn=function(){return e},e}function gn(){var e=Nn(["\n        indirectSpecular += ambientLightColor * materialSpecularColor;\n    "]);return gn=function(){return e},e}function yn(){var e=Nn(["\n            RE_IndirectDiffuse( irradiance, materialDiffuseColor, indirectDiffuse );\n        #endif\n    "]);return yn=function(){return e},e}function bn(){var e=Nn(["\n        HemisphereLight hemisphereLight = hemisphereLights[0];\n        irradiance += getHemisphereLightIrradiance(\n            hemisphereLight.direction,\n            hemisphereLight.groundColor,\n            hemisphereLight.skyColor,\n            geometryNormal );"]);return bn=function(){return e},e}function wn(){var e=Nn(["\n        for ( int i = 0; i < ","; i ++ ) {\n\n            HemisphereLight hemisphereLight = hemisphereLights[ i ];\n            irradiance += getHemisphereLightIrradiance(\n                hemisphereLight.direction,\n                hemisphereLight.groundColor,\n                hemisphereLight.skyColor,\n                geometryNormal );\n\n        }\n    "]);return wn=function(){return e},e}function xn(){var e=Nn(["\n        #if defined( RE_IndirectDiffuse )\n        \n            vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n        \n            #ifdef USE_LIGHTMAP\n        \n                vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n        \n                #ifndef PHYSICALLY_CORRECT_LIGHTS\n        \n                    lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n        \n                #endif\n        \n                irradiance += lightMapIrradiance;\n        \n            #endif\n        "]);return xn=function(){return e},e}function Sn(){var e=Nn(["\n        \n        #if defined( RE_Direct )\n        \n            SpotLight spotLight;\n        \n            ","\n        \n                spotLight = spotLights[ "," ];\n        \n                getSpotDirectLightIrradiance(\n                    spotLight.position,\n                    spotLight.direction,\n                    spotLight.color,\n                    spotLight.coneCos,\n                    spotLight.penumbraCos,\n                    spotLight.distance,\n                    spotLight.decay,\n                    geometryPosition,\n                    directLight.color,\n                    directLight.direction,\n                    directLight.visible);\n        \n                ","\n        \n                RE_Direct(\n                    directLight.color,\n                    directLight.direction,\n                    geometryNormal,\n                    geometryViewDir,\n                    materialDiffuseColor,\n                    materialSpecularColor,\n                    materialSpecularRoughness,\n                    materialSheen,\n                    directDiffuse,\n                    directSpecular,\n                    indirectDiffuse,\n                    indirectSpecular);\n        \n            ","\n        \n        #endif\n    "]);return Sn=function(){return e},e}function On(){var e=Nn(["\n        #if defined( RE_Direct )\n\n            PointLight pointLight;\n        \n            ","\n        \n                pointLight = pointLights[ "," ];\n        \n                getPointDirectLightIrradiance(\n                    pointLight.position,\n                    pointLight.color,\n                    pointLight.distance,\n                    pointLight.decay,\n                    geometryPosition,\n                    directLight.color,\n                    directLight.direction,\n                    directLight.visible);\n        \n                ","\n        \n                RE_Direct(\n                    directLight.color,\n                    directLight.direction,\n                    geometryNormal,\n                    geometryViewDir,\n                    materialDiffuseColor,\n                    materialSpecularColor,\n                    materialSpecularRoughness,\n                    materialSheen,\n                    directDiffuse,\n                    directSpecular,\n                    indirectDiffuse,\n                    indirectSpecular);\n        \n            ","\n        \n        #endif\n        "]);return On=function(){return e},e}function Ln(){var e=Nn(["\n        IncidentLight directLight;"]);return Ln=function(){return e},e}function _n(){var e=Nn(["\n        void CalculateLighting(\n            vec3 geometryNormal, \n            vec3 geometryPosition, \n            vec3 geometryViewDir, \n            float geometryPreBakedOcclusion, \n            vec3 materialDiffuseColor,\n            vec3 materialSpecularColor,\n            float materialSpecularRoughness,\n            float materialSheen,\n            float materialLightingScale,\n            out vec3 directDiffuse, \n            out vec3 directSpecular, \n            out vec3 indirectDiffuse, \n            out vec3 indirectSpecular)\n        {\n            lightingScaleFactor = materialLightingScale;\n\n        //vec4 diffuseColor = vec4( diffuse, opacity );\n        \n        directDiffuse = vec3( 0.0 );\n        directSpecular = vec3( 0.0 );\n        indirectDiffuse = vec3( 0.0 );\n        indirectSpecular = vec3( 0.0 );\n        \n        float specularStrength;\n\n    "]);return _n=function(){return e},e}function Dn(){var e=Nn(["\n        struct PhysicalMaterial {\n        \n            vec3\tdiffuseColor;\n            float\tspecularRoughness;\n            vec3\tspecularColor;\n            float   sheen;\n        \n            #ifndef STANDARD\n                // future\n            #endif\n        \n        };\n        \n        void RE_Direct_Physical(\n            vec3 directLightColor,\n            vec3 directLightDirection,\n            vec3 geometryNormal,\n            vec3 geometryViewDir,\n            vec3 materialDiffuseColor,\n            vec3 materialSpecularColor,\n            float materialSpecularRoughness,\n            float materialSheen,\n            inout vec3 directDiffuse,\n            inout vec3 directSpecular,\n            inout vec3 indirectDiffuse,\n            inout vec3 indirectSpecular)\n        {\n        \n            float dotNL = saturate( dot( geometryNormal, directLightDirection ) );\n        \n            vec3 irradiance = dotNL * directLightColor;\n        \n            #ifndef PHYSICALLY_CORRECT_LIGHTS\n        \n                irradiance *= PI; // punctual light\n        \n            #endif\n\n            directDiffuse += irradiance * BRDF_Diffuse_Lambert( materialDiffuseColor );\n        \n            directSpecular += irradiance * BRDF_Specular_GGX( directLightDirection, geometryNormal, geometryViewDir, materialSpecularColor, materialSpecularRoughness );\n        \n            // Sheen.\n            vec3 halfDir = normalize( directLightDirection + geometryViewDir );\n            float dotHL = saturate( dot(halfDir, directLightDirection) );\n            float sheenAmount = pow(1.0 - dotHL, 5.0);\n            directSpecular += irradiance * materialSheen * sheenAmount;\n        }\n        \n        void RE_IndirectDiffuse_Physical( vec3 irradiance, vec3 materialDiffuseColor, inout vec3 indirectDiffuse ) {\n        \n            indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( materialDiffuseColor );\n        \n        }\n        \n        void RE_IndirectSpecular_Physical( vec3 radiance, vec3 geometryNormal, vec3 geometryViewDir, vec3 materialSpecularColor, float materialSpecularRoughness, inout vec3 indirectSpecular ) {\n        \n            indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometryNormal, geometryViewDir, materialSpecularColor, materialSpecularRoughness );\n        \n        }\n        \n        #define RE_Direct\t\t\t\tRE_Direct_Physical\n        #define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n        #define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n        \n        #define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n        \n        // ref: http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n        float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n        \n            return saturate( pow( abs( dotNV + ambientOcclusion ), exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n        \n        }\n        \n        "]);return Dn=function(){return e},e}function Pn(){var e=Nn(["\n        \n    struct EnvironmentLight {\n        vec3 rgbScale;\n        float saturationScale;\n        float rotateY;\n        float mapWidth;\n    };\n\n    uniform EnvironmentLight environmentLights[ "," ];\n    uniform sampler2D environmentMaps[ "," ];\n\n    vec4 RGBDToLinear( in vec4 value, in float maxRange )\n    {\n        float d = value.a;\n        float dMin = 1.0 / 255.0;\n        d = max(d, dMin); // Shouldn't be needed, but prevents NaN if something has gone wrong.\n        return vec4( value.rgb * ( maxRange / 255.0 ) / d, 1.0 );\n    }\n\n    // Scalek the saturation of an RGB value.\n    vec3 RgbScaleSaturation(vec3 rgb, float saturationScale)\n    {\n        vec3 desaturated = vec3((rgb.r + rgb.g + rgb.b) / 3.0);\n        return mix(desaturated, rgb, saturationScale);\n    }\n\n    // Calculate the uv transform for packed environent maps.\n    // Only valid for mipLevel > 0.\n    void PackedEnvMapMipmapTransform(out vec2 uvOffset, out vec2 uvScale, float mipLevel)\n    {\n        float halfPower = pow(0.5, mipLevel); // 1/2, 1/4, 1/8 ...\n        float vOffset = 0.5 * halfPower;\n        float uOffset = 0.0;\n        float uScale = halfPower;\n        float vScale = 0.5 * uScale;\n        uvOffset = vec2(uOffset, vOffset);\n        uvScale = vec2(uScale, vScale);\n    }\n\n    vec2 WorldDirectionToUv(vec3 worldDirection)\n    {\n        if (abs(worldDirection.z) < 1e-2)\n        {\n            worldDirection.z = 1e-2;\n        }\n        worldDirection = normalize(worldDirection);\n        vec2 uv = vec2(\n            1.0 - (atan(worldDirection.x, worldDirection.z) + PI) / (2.0*PI),\n            (asin(worldDirection.y) + (PI*0.5)) / PI);\n        uv = fract(uv);\n        return uv;\n    }\n\n    // Sample an Image Based environment Light (IBL) for specular\n    // Packed together in a single image and sampled manually rather than using the more \n    // traditional mip chain for two reasons.\n    //  1. Both Teagan and I experienced a bug in Chrome when using manual mip chains.\n    //  2. It means we don't have to use the texture2dLodEXT extension.\n    // Expected image layout:\n    //  +--------------------------------------+\n    //  |                                      |\n    //  |                                      |\n    //  |                                      |\n    //  |        spec0 (original image)        |\n    //  |                                      |\n    //  |                                      |\n    //  |                                      |\n    //  +------------------+-+---------------+-+\n    //  |                  |w|               |w|\n    //  |       spec1      |w|      X        |w|\n    //  |                  |w|               |w|\n    //  +--------+-+-------+-+------+--------+-+\n    //  | spec2  |w|   X   |diffuse |    X   |w|\n    //  +--------+-+-------+--------+--------+-+\n    //  | etc...                               |\n    //\n    vec3 SampleEnvironmentLightSpecular(sampler2D sampler, EnvironmentLight light, vec3 direction, float roughness, float maxMIPLevel ) {\n        vec3 worldDirection = inverseTransformDirection(direction, viewMatrix);\n        mat3 rotateY = RotateY(-light.rotateY);\n        worldDirection = rotateY * worldDirection;\n        float mipLevel = roughness * float(maxMIPLevel);\n        vec2 uv = WorldDirectionToUv(worldDirection);\n        float mipLevel0 = min(floor(mipLevel), maxMIPLevel);\n        float mipLevel1 = min(mipLevel0 + 1.0, maxMIPLevel);\n        float mipT = mipLevel - mipLevel0;\n        vec2 uvOffset0;\n        vec2 uvOffset1;\n        vec2 uvScale0;\n        vec2 uvScale1;\n        if (mipLevel0 < 0.5)\n        {\n            uvOffset0 = vec2(0.0, 0.5);\n            uvScale0 = vec2(1.0, 0.5);\n        }\n        else\n        {\n            PackedEnvMapMipmapTransform(uvOffset0, uvScale0, mipLevel0);\n        }\n        PackedEnvMapMipmapTransform(uvOffset1, uvScale1, mipLevel1);\n        vec2 textureDimensions = vec2(light.mapWidth, light.mapWidth);\n        vec2 texelUvSize = vec2(1, 1) / textureDimensions;\n        vec2 texelUvSize0 = texelUvSize / uvScale0;\n        vec2 texelUvSize1 = texelUvSize / uvScale1;\n        vec2 minUv0 = vec2(0.0, texelUvSize0.y * 0.5);\n        vec2 maxUv0 = vec2(1.0, 1.0) - minUv0;\n        vec2 minUv1 = vec2(0.0, texelUvSize1.y * 0.5);\n        vec2 maxUv1 = vec2(1.0, 1.0) - minUv1;\n        vec2 uv0 = clamp(uv, minUv0, maxUv0) * uvScale0 + uvOffset0;\n        vec2 uv1 = clamp(uv, minUv1, maxUv1) * uvScale1 + uvOffset1;\n        vec4 rgbd0 = ",";\n        vec4 rgbd1 = ",";\n        vec4 rgb0 = RGBDToLinear( rgbd0, 128.0 );\n        vec4 rgb1 = RGBDToLinear( rgbd1, 128.0 );\n        vec4 rgb = mix(rgb0, rgb1, mipT);\n        rgb.xyz *= light.rgbScale;\n        rgb.xyz = RgbScaleSaturation(rgb.xyz, light.saturationScale);\n        rgb.xyz = mix(vec3(1), rgb.xyz, lightingScaleFactor);\n        return rgb.xyz;\n    }\n\n    vec2 SampleEnvironmentReflectanceParameters(sampler2D sampler, EnvironmentLight light, float dotNV, float roughness)\n    {\n        // Location of the LUT in the packed texture.\n        vec2 lutMin = vec2(0.625, 0.25);\n        vec2 lutSize = vec2(0.25, 0.25);\n        vec2 lutMax = lutMin + lutSize;\n        // Calculate safe region for filtering.\n        vec2 textureDimensions = vec2(light.mapWidth, light.mapWidth);\n        vec2 pixelWidth = vec2(1.0, 1.0) / textureDimensions;\n        vec2 halfPixelWidth = pixelWidth / 2.0;\n        vec2 filterMin = lutMin + halfPixelWidth;\n        vec2 filterMax = lutMax - halfPixelWidth;\n        // Calculate the sample point in the packed texture.\n        vec2 uv = vec2(dotNV, 1.0 - roughness);\n        uv = uv * lutSize + lutMin;\n        uv = clamp(uv, filterMin, filterMax);\n        // Sample the lut.\n        vec4 rgbd = ",";\n        vec2 scaleOffset = RGBDToLinear( rgbd, 128.0 ).xy;\n        return scaleOffset;\n    }\n\n    vec3 SampleEnvironmentReflectance(sampler2D sampler, EnvironmentLight light, float dotNV, float roughness, vec3 specularColor)\n    {\n        vec2 scaleOffset = SampleEnvironmentReflectanceParameters(sampler, light, dotNV, roughness);\n        float scale = scaleOffset.x;\n        float offset = scaleOffset.y;\n        // Use the value from the LUT to calculate the approximate specular reflectance.\n        return specularColor * scale + vec3(offset, offset, offset);\n    }\n\n    // Sample an Image Based environment Light for diffuse.\n    // See SampleEnvironmentLightSpecular for more information.\n    vec3 SampleEnvironmentLightDiffuse(sampler2D sampler, EnvironmentLight light, vec3 direction)\n    {\n        vec3 worldDirection = inverseTransformDirection(direction, viewMatrix);\n        mat3 rotateY = RotateY(-light.rotateY);\n        worldDirection = rotateY * worldDirection;\n        vec2 uv = WorldDirectionToUv(worldDirection);\n        vec2 uvOffset;\n        vec2 uvScale;\n        float mipLevel = 2.0; // Diffuse convolution is always in mip 2.\n        PackedEnvMapMipmapTransform(uvOffset, uvScale, mipLevel);\n        uvOffset.x += 0.5; // Diffuse convolution is in a different column than specular.\n        vec2 textureDimensions = vec2(light.mapWidth, light.mapWidth);\n        vec2 texelUvSize = vec2(1, 1) / textureDimensions;\n        texelUvSize = texelUvSize / uvScale;\n        vec2 minUv = vec2(0.0, texelUvSize.y * 0.5);\n        vec2 maxUv = vec2(1.0, 1.0) - minUv;\n        uv = clamp(uv, minUv, maxUv) * uvScale + uvOffset;\n        vec4 rgbd = ",";\n        vec4 rgb = RGBDToLinear( rgbd, 128.0 );\n        rgb.xyz *= light.rgbScale;\n        rgb.xyz = RgbScaleSaturation(rgb.xyz, light.saturationScale);\n        rgb.xyz = mix(vec3(1), rgb.xyz, lightingScaleFactor);\n        return rgb.xyz;\n    }    \n    "]);return Pn=function(){return e},e}function kn(){var e=Nn(["\n        \n        struct HemisphereLight {\n            vec3 direction;\n            vec3 skyColor;\n            vec3 groundColor;\n        };\n    \n        uniform HemisphereLight hemisphereLights[ "," ];\n    \n        vec3 getHemisphereLightIrradiance(\n            vec3 hemiLightDirection,\n            vec3 hemiLightGroundColor,\n            vec3 hemiLightSkyColor,\n            vec3 geometryNormal ) {\n    \n            float dotNL = dot( geometryNormal, hemiLightDirection );\n            float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n    \n            vec3 irradiance = mix( hemiLightGroundColor, hemiLightSkyColor, hemiDiffuseWeight );\n    \n            #ifndef PHYSICALLY_CORRECT_LIGHTS\n    \n                irradiance *= PI;\n    \n            #endif\n    \n            return irradiance;\n    \n        }\n        \n    "]);return kn=function(){return e},e}function Cn(){var e=Nn(["\n\n        struct SpotLight {\n            vec3 position;\n            vec3 direction;\n            vec3 color;\n            float distance;\n            float decay;\n            float coneCos;\n            float penumbraCos;\n    \n            int shadow;\n            float shadowBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n    \n        uniform SpotLight spotLights[ "," ];\n    \n        // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n        void getSpotDirectLightIrradiance(\n            const in vec3 spotLightPosition,\n            const in vec3 spotLightDirection,\n            const in vec3 spotLightColor,\n            const in float spotLightConeCos,\n            const in float spotLightPenumbraCos,\n            const in float spotLightDistance,\n            const in float spotLightDecay,\n            const in vec3 geometryPosition,\n            out vec3 color,\n            out vec3 direction,\n            out bool visible) {\n    \n            vec3 lVector = spotLightPosition - geometryPosition;\n            direction = normalize( lVector );\n    \n            float lightDistance = length( lVector );\n            float angleCos = dot( direction, spotLightDirection );\n    \n            if ( all( bvec2( angleCos > spotLightConeCos, testLightInRange( lightDistance, spotLightDistance ) ) ) ) {\n    \n                float spotEffect = smoothstep( spotLightConeCos, spotLightPenumbraCos, angleCos );\n    \n                color = spotLightColor;\n                color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLightDistance, spotLightDecay );\n    \n                visible = true;\n    \n            } else {\n    \n                color = vec3( 0.0 );\n                visible = false;\n    \n            }\n    \n        }\n    "]);return Cn=function(){return e},e}function Mn(){var e=Nn(["\n        \n        struct PointLight {\n            vec3 position;\n            vec3 color;\n            float distance;\n            float decay;\n    \n            int shadow;\n            float shadowBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n    \n        uniform PointLight pointLights[ "," ];\n    \n        // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n        void getPointDirectLightIrradiance(\n            vec3 pointLightPosition,\n            vec3 pointLightColor,\n            float pointLightDistance,\n            float pointLightDecay,\n            vec3 geometryPosition,\n            out vec3 color,\n            out vec3 direction,\n            out bool visible)\n        {\n            vec3 lVector = pointLightPosition - geometryPosition;\n            direction = normalize( lVector );\n    \n            float lightDistance = length( lVector );\n    \n            if ( testLightInRange( lightDistance, pointLightDistance ) ) {\n    \n                color = pointLightColor;\n                color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLightDistance, pointLightDecay );\n    \n                visible = true;\n    \n            } else {\n    \n                color = vec3( 0.0 );\n                visible = false;\n    \n            }\n    \n        }\n    "]);return Mn=function(){return e},e}function Rn(){var e=Nn(["\n        uniform vec3 ambientLightColor;\n        \n        vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n        \n            vec3 irradiance = ambientLightColor;\n        \n            #ifndef PHYSICALLY_CORRECT_LIGHTS\n        \n                irradiance *= PI;\n        \n            #endif\n        \n            return irradiance;\n        }\n    "]);return Rn=function(){return e},e}function Tn(){var e=Nn(["\n        void getDirectionalDirectLightIrradiance(\n            vec3 directionalLightColor,\n            vec3 directionalLightDirection,\n            out vec3 color,\n            out vec3 direction,\n            out bool visible)\n        {\n            color = directionalLightColor;\n            direction = directionalLightDirection;\n            visible = true;\n        }\n    "]);return Tn=function(){return e},e}function zn(){var e=Nn(['\n        uniform float reflectionWrap;\n\n        vec3 SafeNormalize(vec3 value, vec3 fallback)\n        {\n            vec3 absValue = abs(value);\n            float maxComponent = max(max(absValue.x, absValue.y), absValue.z);\n            vec3 result = fallback;\n            if (maxComponent > 0.0)\n            {\n                result = normalize(value / maxComponent);\n            }\n            return result;\n        }\n\n        vec3 GetPerpendicular(vec3 dir)\n        {\n            vec3 xAxis = vec3(1, 0, 0);\n            vec3 yAxis = vec3(0, 1, 0);\n            vec3 offAxis = xAxis;\n            if (abs(dir.x) > abs(dir.y))\n            {\n                offAxis = yAxis;\n            }\n            vec3 perpendicular = cross(dir, offAxis);\n            perpendicular = normalize(perpendicular);\n            return perpendicular;\n        }\n\n        bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n        \n            return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n        \n        }\n        \n        float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n        \n                if( decayExponent > 0.0 ) {\n        \n        #if defined ( PHYSICALLY_CORRECT_LIGHTS )\n        \n                    // based upon Frostbite 3 Moving to Physically-based Rendering\n                    // page 32, equation 26: E[window1]\n                    // http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n                    // this is intended to be used on spot and point lights who are represented as luminous intensity\n                    // but who must be converted to luminous irradiance for surface lighting calculation\n                    float distanceFalloff = 1.0 / max( pow( abs(lightDistance), decayExponent ), 0.01 );\n                    float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n                    return distanceFalloff * maxDistanceCutoffFactor;\n        \n        #else\n        \n                    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n        \n        #endif\n        \n                }\n        \n                return 1.0;\n        }\n        \n        vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n        \n            return RECIPROCAL_PI * diffuseColor;\n        \n        } // validated\n        \n        \n        vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n        \n            // Original approximation by Christophe Schlick \'94\n            //;float fresnel = pow( abs( 1.0 - dotLH), 5.0 );\n        \n            // Optimized variant (presented by Epic at SIGGRAPH \'13)\n            float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n        \n            return ( 1.0 - specularColor ) * fresnel + specularColor;\n        \n        } // validated\n        \n        \n        // Microfacet Models for Refraction through Rough Surfaces - equation (34)\n        // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n        // alpha is "roughness squared" in Disney’s reparameterization\n        float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n        \n            // geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n        \n            float a2 = pow2( alpha );\n        \n            float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n            float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n        \n            return 1.0 / ( gl * gv );\n        \n        } // validated\n        \n        // from page 12, listing 2 of http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\n        float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n        \n            float a2 = pow2( alpha );\n        \n            // dotNL and dotNV are explicitly swapped. This is not a mistake.\n            float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n            float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n        \n            return 0.5 / max( gv + gl, EPSILON );\n        }\n        \n        // Microfacet Models for Refraction through Rough Surfaces - equation (33)\n        // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n        // alpha is "roughness squared" in Disney’s reparameterization\n        float D_GGX( const in float alpha, const in float dotNH ) {\n        \n            float a2 = pow2( alpha );\n        \n            float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n        \n            return RECIPROCAL_PI * a2 / pow2( denom );\n        \n        }\n        \n        \n        // GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\n        vec3 BRDF_Specular_GGX( vec3 incidentLightDirection, vec3 geometryNormal, vec3 geometryViewDir, vec3 specularColor, float roughness ) {\n        \n            float alpha = pow2( roughness ); // UE4\'s roughness\n        \n            vec3 viewPerp = GetPerpendicular(-geometryViewDir);\n            vec3 reflectionNormal = SafeNormalize(geometryNormal + geometryViewDir * reflectionWrap, viewPerp);\n\n            vec3 halfDir = normalize( incidentLightDirection + geometryViewDir );\n        \n            float dotNL = saturate( dot( reflectionNormal, incidentLightDirection ) );\n            float dotNV = saturate( dot( reflectionNormal, geometryViewDir ) );\n            float dotNH = saturate( dot( reflectionNormal, halfDir ) );\n            float dotLH = saturate( dot( incidentLightDirection, halfDir ) );\n        \n            vec3 F = F_Schlick( specularColor, dotLH );\n        \n            float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n        \n            float D = D_GGX( alpha, dotNH );\n        \n            return F * ( G * D );\n        \n        } // validated\n        \n        \n        // ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\n        vec3 BRDF_Specular_GGX_Environment( vec3 geometryNormal, vec3 geometryViewDir, vec3 specularColor, float roughness ) {\n        \n            float dotNV = saturate( abs( dot( geometryNormal, geometryViewDir ) ) );\n        \n            const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n        \n            const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n        \n            vec4 r = roughness * c0 + c1;\n        \n            float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n        \n            vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n        \n            return specularColor * AB.x + AB.y;\n        \n        } // validated\n        \n        \n        float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n        \n            // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n            return 0.25;\n        \n        }\n        \n        float D_BlinnPhong( const in float shininess, const in float dotNH ) {\n        \n            return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( abs(dotNH), shininess );\n        \n        }\n        \n        vec3 BRDF_Specular_BlinnPhong( IncidentLight incidentLight, vec3 geometryNormal, vec3 geometryViewDir, vec3 specularColor, float shininess ) {\n        \n            vec3 halfDir = normalize( incidentLight.direction + geometryViewDir );\n        \n            //float dotNL = saturate( dot( geometryNormal, incidentLight.direction ) );\n            //float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n            float dotNH = saturate( dot( geometryNormal, halfDir ) );\n            float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n        \n            vec3 F = F_Schlick( specularColor, dotLH );\n        \n            float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n        \n            float D = D_BlinnPhong( shininess, dotNH );\n        \n            return F * ( G * D );\n        \n        } // validated\n        \n        // source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\n        float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n            return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n        }\n        \n        float BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n            return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n        }\n    ']);return zn=function(){return e},e}function jn(){var e=Nn(["\n        struct IncidentLight {\n            vec3 color;\n            vec3 direction;\n            bool visible;\n        };\n\n        // Lighting response of a surface.\n        // Split into categories based on light source and component of the shading model.\n        //  direct      - hard light source. E.g. directional and point lights\n        //  indirect    - soft light source. E.g. hemispherical and environment lights\n        //  Diffuse     - Diffuse reflection.\n        //  Specular    - Specular reflection.\n        // The reason for the split is that different types need different ambient occlusion.\n        struct ReflectedLight {\n            vec3 directDiffuse;\n            vec3 directSpecular;\n            vec3 indirectDiffuse;\n            vec3 indirectSpecular;\n        };\n\n        struct GeometricContext {\n            vec3 position;\n            vec3 normal;\n            vec3 viewDir;\n            float preBakedOcclusion; // Short range occlusion.\n        };\n        "]);return jn=function(){return e},e}function Un(){var e=Nn(["varying float vOcclusionFactor;"]);return Un=function(){return e},e}function Vn(){var e=Nn(["float lightingScaleFactor;"]);return Vn=function(){return e},e}function Nn(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function In(e,n,t){var r=CK.ClientSpecs.check("EXT_shader_texture_lod");t.u({name:"lightingScale",type:"f",value:1}),t.p(Vn()),e.options.vertexOcclusion&&e.p(Un()),t.p(jn()),t.p(zn()),In.directLight(e,n,t),e.options.numDirLights&&t.p(Tn()),Object.assign(e.uniforms,{ambientLightColor:{type:"3fv",value:[0,0,0]},spotLights:{type:"sa",value:[],properties:{color:{type:"c"},position:{type:"v3"},direction:{type:"v3"},distance:{type:"1f"},coneCos:{type:"1f"},penumbraCos:{type:"1f"},decay:{type:"1f"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}},spotShadowMap:{type:"tv",value:[]},spotShadowMatrix:{type:"m4v",value:[]},pointLights:{type:"sa",value:[],properties:{color:{type:"c"},position:{type:"v3"},decay:{type:"1f"},distance:{type:"1f"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},pointShadowMap:{type:"tv",value:[]},pointShadowMatrix:{type:"m4v",value:[]},hemisphereLights:{type:"sa",value:[],properties:{direction:{type:"v3"},skyColor:{type:"c"},groundColor:{type:"c"}}},environmentLights:{type:"sa",value:[],properties:{light:{type:"sa",properties:{rbgScale:{type:"v3"},rotateY:{type:"1f"},mapWidth:{type:"1f"}}},map:{type:"t"}}},environmentMaps:{type:"ta"},reflectionWrap:{type:"1f",value:0}}),t.p(Rn()),e.options.numPointLights&&t.p(Mn(),e.options.numPointLights),e.options.numSpotLights&&t.p(Cn(),e.options.numSpotLights),e.options.numHemiLights&&t.p(kn(),e.options.numHemiLights);var o=function(e,n){return r?(t.extension("GL_EXT_shader_texture_lod"),"texture2DLodEXT(".concat(e,", ").concat(n,", 0.0)")):"texture2D(".concat(e,", ").concat(n,")")};if(e.options.numEnvLights&&t.p(Pn(),e.options.numEnvLights,e.options.numEnvLights,o("sampler","uv0"),o("sampler","uv1"),o("sampler","uv"),o("sampler","uv")),t.p(Dn()),t.p(_n()),t.p(Ln()),e.options.numPointLights){var i=e.options.numPointLights>1?"i":"0";t.p(On(),e.options.numPointLights>1?"for ( int i = 0; i < "+e.options.numPointLights+"; i ++ ) {":"",i,e.options.shadows?"directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ "+i+" ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ "+i+" ] ) : 1.0;":"",e.options.numPointLights>1?"}":"")}if(e.options.numSpotLights){var a=e.options.numSpotLights>1?"i":"0";t.p(Sn(),e.options.numSpotLights>1?"for ( int i = 0; i < "+e.options.numSpotLights+"; i ++ ) {":"",a,e.options.shadows?"directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ "+a+" ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ "+a+" ] ) : 1.0;":"",e.options.numPointLights>1?"}":"")}if(t.p(xn()),e.options.numHemiLights>1?t.p(wn(),e.options.numHemiLights):1===e.options.numHemiLights&&t.p(bn()),t.p(yn()),t.p(gn()),e.options.numEnvLights>0){var c="environmentMaps[0]",u="environmentLights[0]";e.options.numEnvLights>1&&(t.p(mn(),e.options.numEnvLights),c="environmentMaps[i]",u="environmentLights[i]"),e.options.refractionDiceHack&&(t.p(hn()),u="diceHackLight"),t.p(dn(),c,u,c,u,c,u,c,u),e.options.numEnvLights>1&&t.p(vn())}if(e.options.numDirLights){t.p(pn());for(var s=0;s<e.options.numDirLights;++s)t.p(fn(),s),e.options.sunOcclusion&&0==s?(e.options.uv?t.p(ln()):e.options.uv2&&t.p(sn()),(e.options.uv||e.options.uv2)&&t.p(un())):e.options.shadows&&(t.p(cn(),s,s),e.options.preBakedOcclusion&&e.options.normalMap&&e.options.occlusion?t.p(an()):t.p(on())),t.p(rn());t.p(tn())}e.options.occlusion?(t.u({name:"occlusionStrength",type:"f",value:1}),e.options.vertexOcclusion?(n.p(nn()),n(en()),t.u({name:"useDefault",type:"i",value:1}),t.p($e()),t.p(Je()),t.p(Qe())):(t.u({name:"occlusionMap",type:"t",value:X.makeTexture([.75,0,0])}),t.p(Ze()),t.p(qe()),e.debugFrag("occlusionTexture","vec3( texture2D( occlusionMap, vUv.xy * uvPosScl.z + uvPosScl.xy ).r )"),e.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}))):e.options.occlusionCompensate?t.p(Ye()):e.options.preBakedOcclusion&&t.p(Xe()),e.options.sunOcclusion&&(t.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"sunOcclusionMap",type:"t",value:X.makeTexture([0,0,0])})),e.options.preBakedOcclusion&&(e.options.normalMap||e.options.projectedNormalMap)&&(e.options.occlusionCombineMin?t.p(He()):t.p(We())),e.options.occlusion&&t.p(Ge()),(e.options.occlusion||e.options.occlusionCompensate||e.options.preBakedOcclusion)&&(t.p(Ke()),e.options.env&&(t.p(Be(),""),e.options.frostbiteSpecularOcclusion||t.p(Ae()),t.p(Ee()))),(e.options.sunOcclusion||e.options.shadows)&&t.u({name:"shadowStrength",type:"f",value:1}),t.p(Fe())}function Fn(){var e=Yn(["\n    gl_FragColor = vec4(vec2(occlusion / ","), 1.0, 1.0);"]);return Fn=function(){return e},e}function En(){var e=Yn(["\n    {\n        DirectionalLight directionalLight = directionalLights[","];\n        float dotNL = dot( normalize( normal ), normalize( directionalLight.direction ) );\n        float coneScale = saturate( ( dotNL - "," ) / 0.2 );\n        float shadow = getShadow( \n            directionalShadowMap[","], \n            directionalLight.shadowMapSize, \n            directionalLight.shadowBias, \n            directionalLight.shadowRadius, \n            vDirectionalShadowCoord[","] );\n        float visibility = saturate( 1.0 - shadow );\n        float occlusionSample = coneScale * visibility;\n        occlusion += occlusionSample;\n    }"]);return En=function(){return e},e}function An(){var e=Yn(["\n    float occlusion = 0.0;"]);return An=function(){return e},e}function Bn(){var e=Yn(["gl_Position = vec4( ("," + "," ) * 2.0 - 1.0, 0.0, 1.0);"]);return Bn=function(){return e},e}function Kn(){var e=Yn(["gl_PointSize = 1.0;"]);return Kn=function(){return e},e}function Gn(){var e=Yn(["attribute float vertexID;"]);return Gn=function(){return e},e}function Wn(){var e=Yn(["gl_Position = vec4( ( vUv.xy * uvPosScl.z + uvPosScl.xy ) * 2.0 - 1.0, 0.0, 1.0 );"]);return Wn=function(){return e},e}function Hn(){var e=Yn(["gl_Position = vec4( ( uv_seam.xy * uv_seamPosScl.z + uv_seamPosScl.xy ) * 2.0 - 1.0, uv_seam.z, 1.0 );"]);return Hn=function(){return e},e}function Xn(){var e=Yn(["attribute vec3 uv_seam;"]);return Xn=function(){return e},e}function Yn(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function qn(e,n,t){if(e.options.vertexOcclusion){var r=a(e.options.occlusionTextureSize),o="( vec2( mod( ceil( vertexID ), ceil( uvPosScl.z * ".concat(r," ) ), floor( ceil( vertexID ) / (uvPosScl.z * ").concat(r,") ) )  * ( 1.0/").concat(r," ) + (0.5/").concat(r,") )");n.p(Gn()),n(Kn()),n(Bn(),"uvPosScl.xy",o)}else e.options.seamFin?(n.p(Xn()),n.u({name:"uv_seamPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),n(Hn())):n(Wn());n.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),In.directLight(e,n,t);t(An()),e.options.numDirLights<1&&console.error("Must have numDirLights set for gather to work!");for(var i=0;i<e.options.numDirLights;++i)t(En(),i,a(.2),i,i);t(Fn(),a(e.options.numDirLights))}function Zn(){var e=ot(["float preBakedOcclusion = normalPixelX.b * sideRatios.x + normalPixelY.b * sideRatios.y + normalPixelZ.b * sideRatios.z;"]);return Zn=function(){return e},e}function Qn(){var e=ot(["\n    \n        // Reoriented Normal Mapping blend\n        // Triplanar uvs\n        vec2 uvX = vWorldPosition.zy; // x facing plane\n        vec2 uvY = vWorldPosition.xz + 0.33; // y facing plane\n        vec2 uvZ = vWorldPosition.xy + 0.66; // z facing plane\n        \n        vec4 normalPixelX = texture2D( ",", uvX );\n        vec4 normalPixelY = texture2D( ",", uvY );\n        vec4 normalPixelZ = texture2D( ",', uvZ );\n        \n        // Tangent space normal maps\n        vec3 tnormalX = unpackNormal( normalPixelX.rg ) * 2.0 - 1.0;\n        vec3 tnormalY = unpackNormal( normalPixelY.rg ) * 2.0 - 1.0;\n        vec3 tnormalZ = unpackNormal( normalPixelZ.rg ) * 2.0 - 1.0;\n        \n        // Get absolute value of normal to ensure positive tangent "z" for blend\n        vec3 absVertNormal = abs(vWorldNormal);\n        \n        // Swizzle world normals to match tangent space and apply RNM blend\n        tnormalX = rnmBlend( vec3(vWorldNormal.zy, absVertNormal.x), tnormalX);\n        tnormalY = rnmBlend( vec3(vWorldNormal.xz, absVertNormal.y), tnormalY);\n        tnormalZ = rnmBlend( vec3(vWorldNormal.xy, absVertNormal.z), tnormalZ);\n        \n        // Get the sign (-1 or 1) of the surface normal\n        vec3 axisSign = sign(vWorldNormal);\n        \n        // Reapply sign to Z\n        tnormalX.z *= axisSign.x;\n        tnormalY.z *= axisSign.y;\n        tnormalZ.z *= axisSign.z;\n        \n        // Triblend normals and add to world normal\n        vec3 projectedNormal = normalize(\n            tnormalX.xyz * sideRatios.x +\n            tnormalY.xyz * sideRatios.y +\n            tnormalZ.xyz * sideRatios.z +\n            vWorldNormal );\n    \n    ']);return Qn=function(){return e},e}function Jn(){var e=ot(["vec3 sideRatios = abs(vWorldNormal.xyz) / (abs(vWorldNormal.x) + abs(vWorldNormal.y) + abs(vWorldNormal.z));"]);return Jn=function(){return e},e}function $n(){var e=ot(["vWorldNormal = normalize(vec3( modelMatrix * vec4( objectNormal, 1.0) ).xyz );"]);return $n=function(){return e},e}function et(){var e=ot(["vWorldPosition = worldPosition;"]);return et=function(){return e},e}function nt(){var e=ot(["varying vec3 vWorldNormal;"]);return nt=function(){return e},e}function tt(){var e=ot(["varying vec4 vWorldPosition;"]);return tt=function(){return e},e}function rt(){var e=ot(["\n    \n        uniform mat3 normalMatrix;\n\n        vec3 rnmBlend(vec3 n1, vec3 n2) {\n            n1 += vec3( 0.0,  0.0, 1.0);\n            n2 *= vec3(-1.0, -1.0, 1.0);\n            return n1*dot(n1, n2)/n1.z - n2;\n        }"]);return rt=function(){return e},e}function ot(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function it(e,n,t,r){}function at(){var e=Dt(["\n        const vec2 fieldTextureSize = vec2( ",".0, ",".0 );\n\n         float SampleField( in vec3 coords ) {\n\n             float columns = floor( fieldTextureSize.x / fieldSize.x );\n\n             int channel = int( mod( coords.z, 4.0 ) );\n             float gridZ = floor( coords.z / 4.0 );\n\n             float row = floor( gridZ / columns );\n             float column = floor( mod( gridZ, columns ) ) ;\n\n             if( column >= columns ){ //WTF IS THIS AND WHY DOES IT FIX ANDROID?\n                column = 0.0;\n                row +=1.0;\n             }\n\n             float uvX = column * fieldSize.x + coords.x + 0.5;\n             float uvY = row * fieldSize.y + coords.y + 0.5;\n             vec2 uv = vec2( uvX / fieldTextureSize.x, uvY / fieldTextureSize.y );\n\n             vec4 p = texture2D( fieldTexture, uv );\n             if( channel == 0 )return p.r;\n             else if( channel == 1 )return p.g;\n             else if( channel == 2 )return p.b;\n             else return p.a;\n         }\n\n        float MuliSampleField( in vec3 pos ) {\n\n            float floorZ = floor(pos.z);\n            vec3 zUp = vec3( pos.x, pos.y, floorZ + 1.0 );\n            vec3 zDown = vec3( pos.x, pos.y, floorZ );\n\n            float zRatio = pos.z - floorZ; //how much of the top and bottom voxel to get.\n\n            float topSample = SampleField( zUp );\n            float bottomSample = SampleField( zDown );\n\n            return mix( bottomSample, topSample, zRatio );\n\n        }\n\n        vec3 FieldNormal( in vec3 pos ){\n            return -1.0 * normalize(\n                vec3(\n                    MuliSampleField( vec3( pos.x + 1.0, pos.y, pos.z ) ) - MuliSampleField( vec3( pos.x - 1.0, pos.y, pos.z ) ),\n                    MuliSampleField( vec3( pos.x, pos.y + 1.0, pos.z ) ) - MuliSampleField( vec3( pos.x, pos.y - 1.0, pos.z ) ),\n                    MuliSampleField( vec3( pos.x, pos.y, pos.z + 1.0 ) ) - MuliSampleField( vec3( pos.x, pos.y, pos.z - 1.0 ) )\n                )\n            );\n        }\n    "]);return at=function(){return e},e}function ct(){var e=Dt(["\n            vec3 unpackNormal( vec2 normal ){\n                return vec3( normal.r, normal.g, sqrt( -1.0 * (normal.r*normal.r + normal.g * normal.g - 1.0) ) ); //reconstitute normal\n            }\n        "]);return ct=function(){return e},e}function ut(){var e=Dt(["\n            vec3 PerturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 normalPixel, vec2 uvs ) {\n                // return surf_norm;\n                vec3 q0 = dFdx( eye_pos.xyz );\n                vec3 q1 = dFdy( eye_pos.xyz );\n                vec2 st0 = dFdx( uvs.st );\n                vec2 st1 = dFdy( uvs.st );\n\n                vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n                vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n                vec3 N = normalize( surf_norm );\n\n                //vec3 normalPixel = mix( vec3(0,0,1), normalPixel, normalScale.x );\n                mat3 tsn = mat3( S, T, N );\n                return normalize( tsn * normalPixel );\n            }"]);return ut=function(){return e},e}function st(){var e=Dt(["\n            if( flipNormalMap == 1)normalMapPixel.xy = 1.0 - normalMapPixel.xy;\n            vec3 normalMapVector"," = normalMapPixel",".xyz * 2.0 - 1.0;\n            ","\n            normalMapVector = unpackNormal( normalMapVector.xy );\n            normalMapVector",".b = sqrt( -1.0 * (normalMapVector",".r*normalMapVector",".r + normalMapVector",".g * normalMapVector",".g - 1.0) ); //reconstitute normal"]);return st=function(){return e},e}function lt(){var e=Dt(["vec3 normalMapPixel"," = texture2D( normalMap"," , vUv ).xyz;"]);return lt=function(){return e},e}function ft(){var e=Dt(["if(flipNormal == 1){normal = normal * -1.0;}"]);return ft=function(){return e},e}function pt(){var e=Dt(["normal = ",";"]);return pt=function(){return e},e}function vt(){var e=Dt(["normal = PerturbNormal2Arb( -vViewPosition, normal, normalize( unpackNormal( texture2D( normalAtlasMap, vUv.xy * uvPosScl.z + uvPosScl.xy ).rg * 2.0 - 1.0 ) ), vUv.xy * uvPosScl.z + uvPosScl.xy );"]);return vt=function(){return e},e}function dt(){var e=Dt(["normal = PerturbNormal2Arb( -vViewPosition, normal, normalize(normalMapVector), vUv );"]);return dt=function(){return e},e}function ht(){var e=Dt(["preBakedOcclusion = mix( preBakedOcclusion, preBakedOcclusion2, normal2Blend );"]);return ht=function(){return e},e}function mt(){var e=Dt(["normalMapVector = mix( normalMapVector, normalMapVector2, normal2Blend  );"]);return mt=function(){return e},e}function gt(){var e=Dt(["vec3 normal = normalize( vNormal );"]);return gt=function(){return e},e}function yt(){var e=Dt(["\n        vec3 transformedNormal = normalMatrix * objectNormal;\n        vNormal = normalize( transformedNormal ); "]);return yt=function(){return e},e}function bt(){var e=Dt(["\n            skinMatrix /= skinWeightSum;\n            skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n            objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;"]);return bt=function(){return e},e}function wt(){var e=Dt(["\n            skinMatrix += skinWeight","."," * boneMat",";\n            "]);return wt=function(){return e},e}function xt(){var e=Dt(["\n            mat4 skinMatrix = mat4( 0.0 );\n        "]);return xt=function(){return e},e}function St(){var e=Dt(["oNormal = normal;"]);return St=function(){return e},e}function Ot(){var e=Dt(["varying vec3 oNormal;"]);return Ot=function(){return e},e}function Lt(){var e=Dt(["attribute vec3 normal;"]);return Lt=function(){return e},e}function _t(){var e=Dt(["varying vec3 vNormal;"]);return _t=function(){return e},e}function Dt(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Pt(e,n,t){if(e.u({name:"flipNormal",type:"i",value:0}),e.p(_t()),n.p(Lt()),e.options.volumeFieldNormal?function(e,n,t){var r=e.options.volumeTextureSize||console.error("volume texture size not set")||2048;n.u({name:"fieldTexture",type:"t",value:X.zero}),n.u({name:"fieldSize",type:"v3"}),n.u({name:"voxelSize",type:"f"}),n.p(at(),r,r),n.s("start","vec3 objectNormal = FieldNormal( transformed / voxelSize );\n        if(flipNormal == 1)objectNormal = -objectNormal;\n    ")}(e,n):n.s("start","vec3 objectNormal = vec3( normal );\n        if(flipNormal == 1)objectNormal = -objectNormal;\n    "),e.options.oNormal&&(e.p(Ot()),n(St())),e.options.skinning){var r=e.options.skinInfluenceCount||4,o=["x","y","z","w"];n(xt());for(var i=0;i<r;++i){var a=Math.floor(i/4),c=o[i%4];n(wt(),a,c,i)}n(bt())}function u(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";t.u({name:"normalMap"+n,type:"t",value:X.normal}),t(lt(),n,n),t(st(),n,n,e.options.preBakedOcclusion?"float preBakedOcclusion"+n+" = normalMapPixel.b;":"",n,n,n,n,n),e.debugFrag("normalMapPixel"+n),e.debugFrag("normalMapBakedAO"+n,"normalMapPixel"+n+".b")}n(yt()),t(gt()),(e.options.normalMap||e.options.projectedNormalMap||e.options.normalAtlas)&&Pt.perturbNormal(e,n,t),e.options.normalMap?(u(""),t.u({name:"flipNormalMap",type:"i",value:0}),e.options.normalMap2&&(t.u({name:"normal2Blend",type:"f",value:0}),u("2"),t(mt()),e.options.preBakedOcclusion&&t(ht())),t.section("perturbNormalMapVector"),t(dt()),e.options.normalAtlas):e.options.normalAtlas&&(t.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"normalAtlasMap",type:"t",value:X.gray}),t(vt())),e.options.projectedNormalMap&&(t.u({name:"projectedNormalMap",type:"t",value:X.normal}),t(pt(),it.normal(e,n,t,"projectedNormalMap"))),t(ft()),t.section("normalInitialized"),e.debugFrag("finalNormal","normal"),e.debugFrag("flipNormal")}function kt(){var e=cr(["if(diffuseColor.a < 0.004 )diffuseColor.a = 0.004;"]);return kt=function(){return e},e}function Ct(){var e=cr(["diffuseColor = mix( diffuseColor, emissiveResult, "," * inLayerBounds );"]);return Ct=function(){return e},e}function Mt(){var e=cr(["diffuseColor = mix( diffuseColor, emissiveResult , "," * inLayerBounds );"]);return Mt=function(){return e},e}function Rt(){var e=cr(["if(diffuseColor.a < 0.004 )diffuseColor.a = 0.004;"]);return Rt=function(){return e},e}function Tt(){var e=cr(["diffuseColor = mix( diffuseColor, physicalResult, "," * inLayerBounds );"]);return Tt=function(){return e},e}function zt(){var e=cr(["diffuseColor = mix( diffuseColor, physicalResult, "," * inLayerBounds );"]);return zt=function(){return e},e}function jt(){var e=cr(["diffuseColor = vec4( mix( diffuseColor.rgb, layerColor.rgb, layerColor.a * inLayerBounds ), 1.0);"]);return jt=function(){return e},e}function Ut(){var e=cr(["layerColor = ",";"]);return Ut=function(){return e},e}function Vt(){var e=cr([" layerColor.a = ","*",".a;\n                       layerColor.rgb = ",".rgb; "]);return Vt=function(){return e},e}function Nt(){var e=cr(["  layerColor.a = ","* gradientResult.a; //TODO: early out after alpha\n                        layerColor.rgb = gradientResult.rgb; "]);return Nt=function(){return e},e}function It(){var e=cr(["diffuseColor = vec4( blendOverlay(diffuseColor.rgb, ",".rgb , "," * inLayerBounds), 1.0);"]);return It=function(){return e},e}function Ft(){var e=cr(["diffuseColor.a = 1.0;"]);return Ft=function(){return e},e}function Et(){var e=cr(["depth = mix( depth, ",", "," * inLayerBounds );"]);return Et=function(){return e},e}function At(){var e=cr(["  layerNormal = vec3( ","* 2.0 - 1.0, "," * 2.0 - 1.0, 0.0 );\n                        layerNormal.z = 1.0- pow( abs(layerNormal.x), 2.0) - pow(abs(layerNormal.y), 2.0); //reform the z component\n                        normalAccumulation = mix( normalAccumulation, NormalBlend_UnpackedRNM( normalAccumulation, layerNormal ), inLayerBounds);"]);return At=function(){return e},e}function Bt(){var e=cr([" "," = miniPaint( vec4(","[0].rgb, ","[0]), vec4(","[1].rgb, ","[1]), vec4(","[2].rgb, ","[2]), vec4(","[3].rgb, ","[3]), "," );"]);return Bt=function(){return e},e}function Kt(){var e=cr([""," = miniPaint( vec4( ","[0], ","[0], ","[0], ","[0] ) , vec4( ","[1], ","[1], ","[1], ","[1] ) , vec4( ","[2], ","[2], ","[2], ","[2] ), "," );"]);return Kt=function(){return e},e}function Gt(){var e=cr([" "," = miniPaint( ","[0], ","[1], ","[2], ","[3], "," );"]);return Gt=function(){return e},e}function Wt(){var e=cr(["vec3 aaID = vec3(0,0,0);"]);return Wt=function(){return e},e}function Ht(){var e=cr(["vec3 aaID = texture2D( aaidMap, layerUvs ).rgb;"]);return Ht=function(){return e},e}function Xt(){var e=cr(["vec4 "," = texture2D( ",", "," );"]);return Xt=function(){return e},e}function Yt(){var e=cr(["inLayerBounds = 1.0;"]);return Yt=function(){return e},e}function qt(){var e=cr(["\n            inLayerBounds = saturate ( ( min( MinComponent( 1.0 - saturate(layerUvs) ),MinComponent( saturate( layerUvs ) ) ) - 0.01 ) * 1.0/0.1 );\n        "]);return qt=function(){return e},e}function Zt(){var e=cr(["layerUvs = ",";"]);return Zt=function(){return e},e}function Qt(){var e=cr(["layerUvs = vec2( ",".x / ",".z - ",".x / ",".z , ",".y / ",".w - ",".y / ",".w );"]);return Qt=function(){return e},e}function Jt(){var e=cr(["diffuseColor = vec4( 0.5,0.5, 0.5, 1.0 );"]);return Jt=function(){return e},e}function $t(){var e=cr(["normal = PerturbNormal2Arb( -vViewPosition, normal, normalize(normalAccumulation) );"]);return $t=function(){return e},e}function er(){var e=cr(["\n                normalAccumulation.z *= 0.3; //TODO: Artificial normal map bumping here. Yuck.\n                normalAccumulation = normalize(normalAccumulation);\n                diffuseColor = vec4( (normalAccumulation.r + 1.0 ) * 0.5, ( normalAccumulation.g + 1.0 ) * 0.5, depth, 1.0 );\n            "]);return er=function(){return e},e}function nr(){var e=cr(["  vec3 normalAccumulation = vec3(0.0,0.0,1.0);\n            vec3 layerNormal;\n            float depth = 0.5;\n        "]);return nr=function(){return e},e}function tr(){var e=cr(["\n        vec4 emissiveResult;\n    "]);return tr=function(){return e},e}function rr(){var e=cr(["\n        vec4 physicalResult;\n    "]);return rr=function(){return e},e}function or(){var e=cr(["\n        vec4 layerColor;    \n        vec4 gradientResult;\n    "]);return or=function(){return e},e}function ir(){var e=cr(["vec2 layerUvs;\n    float inLayerBounds;"]);return ir=function(){return e},e}function ar(){var e=cr(["\n        float blendOverlay(float base, float blend) {\n            return base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n        }\n    \n        vec3 blendOverlay(vec3 base, vec3 blend) {\n            return vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n        }\n    \n        vec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n            return (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n        }\n        \n        // RNM - Already unpacked\n        vec3 NormalBlend_UnpackedRNM(vec3 n1, vec3 n2){\n            n1 += vec3(0.0, 0.0, 1.0);\n            n2 *= vec3(-1.0, -1.0, 1.0);\n            return n1*dot(n1, n2)/n1.z - n2;\n        }\n        \n        float getAAIDContribution( int id, vec3 aaID ){\n            if( id == int( floor(aaID.r * 255.0 + 0.5 ) ) )return 1.0 - aaID.b;\n            else if( id == int( floor(aaID.g * 255.0 + 0.5 ) ) )return aaID.b;\n            return 0.0;\n        }\n        \n        vec4 miniPaint( vec4 wash, vec4 base, vec4 highlight, vec4 special, vec4 masks ){\n            return mix( mix( mix( base, wash, masks.g ), highlight, masks.r ), special, masks.b * special.a);\n        }\n        \n        vec4 miniPaint( vec4 wash, vec4 base, vec4 highlight, vec4 masks ){\n            return mix( mix( base, wash, masks.g ), highlight, masks.r );\n        }\n        \n        float miniPaint( float wash, float base, float highlight, vec4 masks ){\n            return mix( mix( base, wash, masks.g ), highlight, masks.r );\n        }\n    "]);return ar=function(){return e},e}function cr(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function ur(e,n){return"ckUserColor_"+e+"_"+n+"_color"}function sr(e,n,t){var r=e.options.layers;if(void 0!==r&&0!==Object.keys(r).length){t.p(ar());var o=!1;for(var i in r){if(r[i].decal.layerTypeCounts.normal){o=!0;break}}var a,c,u,s,l,f,p=e.options.depthLayers||e.options.normalLayers&&o,v=e.options.colorLayers,d=e.options.physicalLayers,h=e.options.emissiveLayers;t(ir()),v&&t(or()),d&&t(rr()),h&&t(tr()),p&&(Pt.perturbNormal(e,n,t),t(nr()));var m=function(n){var o=r[n],i=o.slot,m=o.decal;a=e.options.uv2&&!m.baseLayer&&void 0!==m.uvwh?"vUv2":"vUv",c=1/m.panelCount,void 0!==m.uvwh?(u="uvLayerOffset_"+n,t.u({name:u,type:"v4",value:new RK.Vec4(0,0,1,1)}),t(Qt(),a,u,u,u,a,u,u,u)):t(Zt(),a);var g=void 0!==m.uvwh&&!m.baseLayer;t(g?qt():Yt()),s="packedMap_"+n,t.u({name:s,type:"t"});var y={},b=function(e){if(f=s+"_"+e,!(e in y)){y[e]=!0;var n=m.baseLayer?"layerUvs":"vec2(layerUvs.x / float(".concat(m.panelCount,") + float(").concat(c*e,"),layerUvs.y)");t(Xt(),f,s,n)}return f},w=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=m.layerChannels[e]+n;return b(Math.floor(t/m.channelCount))+"["+t%m.channelCount+"]"};m.hasAAID?(t.u({name:"aaidMap",type:"t"}),t(Ht())):m.baseLayer&&t(Wt());var x=function(e){return"getAAIDContribution( ".concat(e,", aaID )")},S=function(e){return b(m.layerChannels[e]/m.channelCount)},O=function(){var e=[];for(var t in m.layerTypes[l])"color"===m.layerTypes[l]?e.push(S(l)+".a"):"solid"===m.layerTypes[l]&&e.push(w(l));if(0===e.length)return"1.0";if(1===e.length)return e[0];for(var r=e[n],o=1;o<e.length;o++)r="max( "+e[o]+", "+r+")";return r+";"},L=function(e){var n=ur(m.layerMappings[e],i);return n in t.uniforms||t.u({name:n,type:"v4",value:new RK.Vec4(0,.5,.2,1)}),n},_=function(e,n){var r=ur(m.layerMappings[e],i);r in t.uniforms||t.u({name:r,type:"v4v",value:[new RK.Vec3(0,0,1),new RK.Vec3(0,1,0),new RK.Vec3(1,0,0),new RK.Vec3(1,0,0)],undefined:void 0,count:4}),t(Gt(),n,r,r,r,r,b(0))},D=function(e,n){var r="ckUserPhysical_"+m.layerMappings[e]+"_"+i+"_roughness",o="ckUserPhysical_"+m.layerMappings[e]+"_"+i+"_metalness",a="ckUserPhysical_"+m.layerMappings[e]+"_"+i+"_emissive",c="ckUserPhysical_"+m.layerMappings[e]+"_"+i+"_sheen";r in t.uniforms||t.u({name:r,type:"v3",value:new RK.Vec3(.5,.5,.5)}),o in t.uniforms||t.u({name:o,type:"v3",value:new RK.Vec3(0,0,0)}),a in t.uniforms||t.u({name:a,type:"v3",value:new RK.Vec3(0,0,0)}),c in t.uniforms||t.u({name:c,type:"v3",value:new RK.Vec3(0,0,0)}),t(Kt(),n,r,o,a,c,r,o,a,c,r,o,a,c,b(0))},P=function(e,n){var r="ckUserEmissive_"+m.layerMappings[e]+"_"+i+"_color",o="ckUserEmissive_"+m.layerMappings[e]+"_"+i+"_alpha";r in t.uniforms||t.u({name:r,type:"v4v",value:[new RK.Vec3(0,0,1),new RK.Vec3(0,1,0),new RK.Vec3(1,0,0),new RK.Vec3(1,0,0)],undefined:void 0,count:4}),o in t.uniforms||t.u({name:o,type:"v4",value:new RK.Vec4(1,1,1,1)}),t(Bt(),n,r,o,r,o,r,o,r,o,b(0))};if(p&&(m.layerTypeCounts.normal>0||m.layerTypeCounts.depth>0))for(var k=0,C=m.layerTypes.length;k<C;k++){var M=m.layerTypes[k];"normal"!==M&&"depth"!==M||t(At(),w(k),w(k,1))}if(p&&m.layerTypeCounts.depth>0)for(var R=0,T=m.layerTypes.length;R<T;R++)"depth"===m.layerTypes[R]&&t(Et(),w(R,2),O());if(v)for(var z=0,j=m.layerTypes.length;z<j;z++){var U=m.layerTypes[z];"base"===U?(_(z,"diffuseColor"),t(Ft()),e.debugFrag("baseGradients","".concat(b(0),".r"))):"overlay"===U?t(It(),L(z),w(z)):"baseGradient"===U?(_(z,"gradientResult"),t(Nt(),x(m.layerChannels[z]-2))):"solid"===U?t(Vt(),w(z),L(z),L(z)):"color"===U&&t(Ut(),S(z)),"baseGradient"!==U&&"solid"!==U&&"color"!==U||t(jt())}if(d){for(var V=0,N=m.layerTypes.length;V<N;V++){var I=m.layerTypes[V];"base"===I?D(V,"diffuseColor"):"baseGradient"===I?(D(V,"physicalResult"),t(zt(),x(m.layerChannels[V]-2))):"solid"===I&&(D(V,"physicalResult"),t(Tt(),w(V)))}t(Rt())}if(h)for(var F=0,E=m.layerTypes.length;F<E;F++){var A=m.layerTypes[F];"base"===A?P(F,"diffuseColor"):"baseGradient"===A?(P(F,"emissiveResult"),t(Mt(),x(m.layerChannels[F]-2))):"solid"===A&&(P(F,"emissiveResult"),t(Ct(),w(F))),t(kt())}};for(var g in r)m(g);p?e.options.bake?t(er()):e.options.normalMap?t.s("perturbNormalMapVector","normalMapVector = NormalBlend_UnpackedRNM( normalMapVector, normalAccumulation );"):t($t()):e.options.bake&&e.options.normalLayers&&t(Jt())}}function lr(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["\n        vec3 surfaceMasks = texture2D( surfaceGradientMap, vUv ).rgb;\n        \n        diffuseColor = SrgbToLinear( mix( mix( diffuseColorRange[1],  diffuseColorRange[2], surfaceMasks.r ),  diffuseColorRange[0], surfaceMasks.g ) );\n        roughnessFactor = mix( mix( roughnessRange[1],  roughnessRange[2], surfaceMasks.r ),  roughnessRange[0], surfaceMasks.g );\n        sheenFactor = mix( mix( sheenRange[1],  sheenRange[2], surfaceMasks.r ),  sheenRange[0], surfaceMasks.g );\n        metalnessFactor = mix( mix( metalnessRange[1],  metalnessRange[2], surfaceMasks.r ),  metalnessRange[0], surfaceMasks.g );\n        totalEmissiveRadiance = SrgbToLinear( mix( mix( emissiveRange[1],  emissiveRange[2], surfaceMasks.r ),  emissiveRange[0], surfaceMasks.g ).xyz );\n        alphaFactor = mix( mix( alphaRange[1],  alphaRange[2], surfaceMasks.r ),  alphaRange[0], surfaceMasks.g );\n\n    "]);return lr=function(){return e},e}function fr(e,n,t){if(!e.options.eye){if(t.u({name:"refraction",type:"f",value:.68}),e.options.refraction&&e.options.refractionEnvMap&&t.u({name:"refractionEnvMap",type:"t",value:X.transparentBlack}),t.s("start","vec4 diffuseColor = vec4(0.5, 0.5, 0.5, 1.0);"),e.options.colorMap?(t.u({name:"colorMap",type:"t",value:X.gray}),t.s("start","diffuseColor = vec4(texture2D( colorMap, vUv ).rgb, 1.0);")):e.options.colorAtlas||(t.u({name:"diffuse",type:"v3",value:new RK.Vec3(.73,.73,.73)}),t.s("start","diffuseColor = vec4( diffuse, 1.0 );")),t.s("start","\n        vec3 totalEmissiveRadiance = vec3(0, 0, 0);\n        float alphaFactor = 1.0;\n        float roughnessFactor = 0.8;\n        float metalnessFactor = 0.0;\n        float sheenFactor = 0.0;\n        // Input diffuse colours are in srgb space. Convert them to linear.\n        diffuseColor.rgb = SrgbToLinear(diffuseColor.rgb);"),e.options.emissiveAtlas||(t.u({name:"emissive",type:"v3",value:new RK.Vec3(0,0,0)}),t.s("start","totalEmissiveRadiance = emissive;")),e.options.physicalAtlas||(t.u({name:"alpha",type:"f",value:1}),t.u({name:"roughness",type:"f",value:.8}),t.u({name:"metalness",type:"f",value:0}),t.u({name:"sheen",type:"f",value:0}),t.s("start","\n        alphaFactor = alpha;\n        roughnessFactor = roughness;\n        metalnessFactor = ".concat(e.options.env?"metalness":"0.0","; ","\n        sheenFactor = sheen;"))),t.s("normalInitialized","\n        GeometricContext geometry;\n        geometry.position = - vViewPosition;\n        geometry.normal = normal;\n        geometry.viewDir = normalize( vViewPosition );\n        geometry.preBakedOcclusion = 1.0;\n        "),e.options.preBakedOcclusion&&t.s("normalInitialized","\n            geometry.preBakedOcclusion = preBakedOcclusion;\n            "),e.options.surface&&function(e,n,t){e.options.eye||(t.u({name:"diffuseColorRange",type:"v4v",value:[new RK.Vec4(0,0,1,1),new RK.Vec4(0,1,0,1),new RK.Vec4(1,0,0,1)],undefined:void 0,count:3}),t.u({name:"roughnessRange",type:"v3",value:new RK.Vec3(0,0,0)}),t.u({name:"metalnessRange",type:"v3",value:new RK.Vec3(0,0,0)}),t.u({name:"surfaceGradientMap",type:"t",value:X.gray}),t.u({name:"emissiveRange",type:"v4v",value:[new RK.Vec4(0,0,0,0),new RK.Vec4(0,0,0,0),new RK.Vec4(0,0,0,0)],undefined:void 0,count:3}),t.u({name:"alphaRange",type:"v3",value:new RK.Vec3(1,1,1)}),t.u({name:"sheenRange",type:"v3",value:new RK.Vec3(0,0,0)}),t(lr()))}(e,0,t),t.s("end","\n        PhysicalMaterial material;\n        material.diffuseColor = saturate( diffuseColor.rgb ) * ( 1.0 - metalnessFactor );\n        material.specularRoughness = roughnessFactor;\n        material.sheen = sheenFactor;\n        ".concat("\n        material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n        ",e.options.lightingScaleMetalBias>0?"\n        float materialLightingScale = pow(lightingScale, 1.0 - ".concat(Math.min(e.options.lightingScaleMetalBias,.99)," * clamp(metalnessFactor, 0.0, 1.0));\n            "):"\n        float materialLightingScale = lightingScale;\n            ","\n\n        ReflectedLight reflectedLight;\n        CalculateLighting(\n            geometry.normal, \n            geometry.position, \n            geometry.viewDir, \n            geometry.preBakedOcclusion, \n            material.diffuseColor,\n            material.specularColor,\n            material.specularRoughness,\n            material.sheen,\n            materialLightingScale,\n            reflectedLight.directDiffuse, \n            reflectedLight.directSpecular, \n            reflectedLight.indirectDiffuse, \n            reflectedLight.indirectSpecular);\n        ")),t.s("end","\n        vec3 outgoingLight \n            = reflectedLight.directDiffuse \n            + reflectedLight.indirectDiffuse \n            + reflectedLight.directSpecular \n            + reflectedLight.indirectSpecular \n            + totalEmissiveRadiance;"),e.options.refraction&&(e.options.numEnvLights>0||e.options.refractionEnvMap)){t.s("end","\n                ".concat("\n                float inverseRefraction = 1.0 - refraction;\n                ","\n                float ior = inverseRefraction * inverseRefraction + 0.5 * inverseRefraction + 0.5;\n                ","\n                vec3 transmittedLight = vec3(0);\n                vec3 refractView = refract(geometry.viewDir, geometry.normal, ior);\n                vec3 interiorNormal = -geometry.normal;\n                vec3 viewPerp = GetPerpendicular(-refractView);\n                vec3 reflectionNormal = SafeNormalize(interiorNormal + refractView * reflectionWrap, viewPerp);\n                vec3 reflectVec = reflect( -refractView, reflectionNormal );\n                float dotNv = abs(dot( refractView, interiorNormal ));\n                float meanDotNv = 0.637; // Cosine weighted mean dot(normal, view)\n                dotNv = mix(dotNv, meanDotNv, reflectionWrap);\n                vec2 reflectanceParams = vec2(1, 0);\n                float refractionRoughnessMin = 0.3; ","\n                "));var r="environmentMaps[0]",o="environmentLights[0]";e.options.refractionEnvMap?(r="refractionEnvMap",t.s("end","EnvironmentLight refractionLight;\n                refractionLight.rgbScale = vec3(2, 2, 2);\n                refractionLight.saturationScale = 1.0;\n                refractionLight.rotateY = 0.0;\n                refractionLight.mapWidth = 512.0;\n                "),o="refractionLight"):e.options.numEnvLights>1?(t.s("end","\n                for ( int i = 0; i < ".concat(e.options.numEnvLights,"; i ++ )")),r="environmentMaps[i]",o="environmentLights[i]"):e.options.refractionDiceHack&&(t.s("end","EnvironmentLight refractionLight;\n                refractionLight.rgbScale = vec3(10, 10, 10);\n                refractionLight.saturationScale = 0.0;\n                refractionLight.rotateY = 0.0;\n                refractionLight.mapWidth = 512.0;\n                refractionRoughnessMin = 0.0; ".concat("\n                ")),o="refractionLight"),t.s("end","\n            {\n                float envMapMaxMip = 4.0;\n                float refractionRoughness = mix(refractionRoughnessMin, 1.0, material.specularRoughness);\n                vec3 envSpecularIrradiance \n                    = SampleEnvironmentLightSpecular(\n                        ".concat(r,", \n                        ").concat(o,", \n                        reflectVec, \n                        refractionRoughness, \n                        envMapMaxMip);\n                reflectanceParams \n                    = SampleEnvironmentReflectanceParameters(\n                        ").concat(r,", \n                        ").concat(o,", \n                        dotNv, \n                        refractionRoughness);\n                transmittedLight += envSpecularIrradiance * diffuseColor.rgb;\n            }\n            ")),t.s("end","\n            float transmittance = saturate(min(1.0 - alphaFactor, 1.0 - reflectanceParams.y));\n            outgoingLight = mix(outgoingLight, transmittedLight, transmittance);")}t.s("end","\n\n        ".concat("\n        gl_FragColor = vec4( LinearToSrgb(outgoingLight), diffuseColor.a );\n        "))}}function pr(){var e=Or(["objectNormal += morphFlip * ( morphNormal"," - normal ) * morphWeight",";"]);return pr=function(){return e},e}function vr(){var e=Or(["transformed += morphTarget"," * morphWeight",";"]);return vr=function(){return e},e}function dr(){var e=Or(["int morphColorId = int(round(vColor.r*32.0))+1;\n                if( !(morphColorId == ",") ){\n                    morphWeight"," = 0.0;\n                }"]);return dr=function(){return e},e}function hr(){var e=Or(["morphWeight"," *= 1.0 - hidePerVertex;"]);return hr=function(){return e},e}function mr(){var e=Or(["morphWeight"," = hidePerVertex;"]);return mr=function(){return e},e}function gr(){var e=Or(["attribute vec3 morphNormal",";"]);return gr=function(){return e},e}function yr(){var e=Or(["float morphWeight"," = morphTargetInfluences[","];"]);return yr=function(){return e},e}function br(){var e=Or(["attribute vec3 morphTarget",";"]);return br=function(){return e},e}function wr(){var e=Or(["float morphFlip = 1.0 - (float(flipNormal) * 2.0);"]);return wr=function(){return e},e}function xr(){var e=Or(["uniform float morphTargetInfluences[","];"]);return xr=function(){return e},e}function Sr(){var e=Or(["attribute float hidePerVertex;"]);return Sr=function(){return e},e}function Or(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Lr(e,n,t){if(e.options.morphTargets){var r=void 0!==e.options.colorIdMorphs&&e.options.colorIdMorphs.length>0&&e.options.colors,o=e.options.hidePerVertex;o?n.p(Sr()):r&&e.add(Te);var i=e.options.morphNormals&&!e.options.depth,a=i?4:7;n.p(xr(),a),i&&n(wr());for(var c=0;c<a;c++)n.p(br(),c),n(yr(),c,c),i&&n.p(gr(),c),o?n(0===c?mr():hr(),c):r&&0===c&&n(dr(),e.options.colorIdMorphs.join("|| morphColorId == "),c),n(vr(),c,c),i&&n(pr(),c,c)}}function _r(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["\n        vec4 TwoVectorQuaternion(vec3 from, vec3 to)\n        {\n            vec4 quat;\n            vec3 a = cross(from, to);\n            quat.xyz = a;\n            quat.w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n            quat = normalize(quat);\n            return quat;\n        }\n\n        vec3 QuaternionVectorRotate(vec4 quaternion, vec3 vector)\n        {\n            return vector + 2.0 * cross(quaternion.xyz, cross(quaternion.xyz, vector) + quaternion.w * vector);\n        }\n        "]);return _r=function(){return e},e}function Dr(){var e=Fr(["\n        for ( int i = 0; i < ","; i ++ ) {\n            vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n        }\n    "]);return Dr=function(){return e},e}function Pr(){var e=Fr(["\n        vPointShadowCoord[ 0 ] = pointShadowMatrix[ 0 ] * worldPosition;\n    "]);return Pr=function(){return e},e}function kr(){var e=Fr(["\n        for ( int i = 0; i < ","; i ++ ) {\n            vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n        }\n    "]);return kr=function(){return e},e}function Cr(){var e=Fr(["\n        vSpotShadowCoord[ 0 ] = spotShadowMatrix[ 0 ] * worldPosition;\n    "]);return Cr=function(){return e},e}function Mr(){var e=Fr(["\n        for ( int i = 0; i < ","; i ++ ) {\n            vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n        }\n    "]);return Mr=function(){return e},e}function Rr(){var e=Fr(["\n        vDirectionalShadowCoord[ 0 ] = directionalShadowMatrix[ 0 ] * worldPosition;\n    "]);return Rr=function(){return e},e}function Tr(){var e=Fr(["\n        \n        float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n        \n            return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n        \n        }\n        \n        float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n        \n            const vec2 offset = vec2( 0.0, 1.0 );\n        \n            vec2 texelSize = vec2( 1.0 ) / size;\n            vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n        \n            float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n            float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n            float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n            float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n        \n            vec2 f = fract( uv * size + 0.5 );\n        \n            float a = mix( lb, lt, f.y );\n            float b = mix( rb, rt, f.y );\n            float c = mix( a, b, f.x );\n        \n            return c;\n        \n        }\n        \n        float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n        \n            float result = 0.0;\n\n            shadowCoord.xyz /= shadowCoord.w;\n            shadowCoord.z += shadowBias;\n        \n            // if ( something && something ) breaks ATI OpenGL shader compiler\n            // if ( all( something, something ) ) using this instead\n        \n            bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n            bool inFrustum = all( inFrustumVec );\n        \n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n        \n            bool frustumTest = all( frustumTestVec );\n        \n            if ( frustumTest ) {\n        \n                vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n        \n                float dx0 = - texelSize.x * shadowRadius;\n                float dy0 = - texelSize.y * shadowRadius;\n                float dx1 = + texelSize.x * shadowRadius;\n                float dy1 = + texelSize.y * shadowRadius;\n        \n                result = (\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n                    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n                ) * ( 1.0 / 9.0 );\n        \n            }\n            else\n            {\n                result = 1.0;\n            }\n            return result;\n        }\n        \n        float getShadowBinary( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n        \n            float result = 0.0;\n\n            shadowCoord.xyz /= shadowCoord.w;\n            shadowCoord.z += shadowBias;\n        \n            bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n            bool inFrustum = all( inFrustumVec );\n        \n            bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n        \n            bool frustumTest = all( frustumTestVec );\n        \n            if ( frustumTest ) result = texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z );\n            else result = 1.0;\n            \n            return result;\n        }\n        \n        // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n        // vector suitable for 2D texture mapping. This code uses the following layout for the\n        // 2D texture:\n        //\n        // xzXZ\n        //  y Y\n        //\n        // Y - Positive y direction\n        // y - Negative y direction\n        // X - Positive x direction\n        // x - Negative x direction\n        // Z - Positive z direction\n        // z - Negative z direction\n        //\n        // Source and test bed:\n        // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n        \n        vec2 cubeToUV( vec3 v, float texelSizeY ) {\n        \n            // Number of texels to avoid at the edge of each square\n        \n            vec3 absV = abs( v );\n        \n            // Intersect unit cube\n        \n            float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n            absV *= scaleToCube;\n        \n            // Apply scale to avoid seams\n        \n            // two texels less per square (one texel will do for NEAREST)\n            v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n        \n            // Unwrap\n        \n            // space: -1 ... 1 range for each square\n            //\n            // #X##\t\tdim    := ( 4 , 2 )\n            //  # #\t\tcenter := ( 1 , 1 )\n        \n            vec2 planar = v.xy;\n        \n            float almostATexel = 1.5 * texelSizeY;\n            float almostOne = 1.0 - almostATexel;\n        \n            if ( absV.z >= almostOne ) {\n        \n                if ( v.z > 0.0 )\n                    planar.x = 4.0 - v.x;\n        \n            } else if ( absV.x >= almostOne ) {\n        \n                float signX = sign( v.x );\n                planar.x = v.z * signX + 2.0 * signX;\n        \n            } else if ( absV.y >= almostOne ) {\n        \n                float signY = sign( v.y );\n                planar.x = v.x + 2.0 * signY + 2.0;\n                planar.y = v.z * signY - 2.0;\n        \n            }\n        \n            // Transform to UV space\n        \n            // scale := 0.5 / dim\n            // translate := ( center + 0.5 ) / dim\n            return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n        \n        }\n        \n        float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n        \n            vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n        \n            // for point lights, the uniform @vShadowCoord is re-purposed to hold\n            // the distance from the light to the world-space position of the fragment.\n            vec3 lightToPosition = shadowCoord.xyz;\n        \n            // bd3D = base direction 3D\n            vec3 bd3D = normalize( lightToPosition );\n            // dp = distance from light to fragment position\n            float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n        \n            #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n        \n                vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n        \n                return (\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n                    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n                ) * ( 1.0 / 9.0 );\n        \n            #else // no percentage-closer filtering\n        \n                return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n        \n            #endif\n        \n        }"]);return Tr=function(){return e},e}function zr(){var e=Fr(["\n        uniform sampler2D pointShadowMap[ "," ];\n        varying vec4 vPointShadowCoord[ "," ];\n    "]);return zr=function(){return e},e}function jr(){var e=Fr(["\n        uniform sampler2D spotShadowMap[ "," ];\n        varying vec4 vSpotShadowCoord[ "," ];\n    "]);return jr=function(){return e},e}function Ur(){var e=Fr(["\n        uniform sampler2D directionalShadowMap[ "," ];\n        varying vec4 vDirectionalShadowCoord[ "," ];\n    "]);return Ur=function(){return e},e}function Vr(){var e=Fr(["\n        uniform mat4 pointShadowMatrix[ "," ];\n        varying vec4 vPointShadowCoord[ "," ];\n    "]);return Vr=function(){return e},e}function Nr(){var e=Fr(["\n        uniform mat4 spotShadowMatrix[ "," ];\n        varying vec4 vSpotShadowCoord[ "," ];\n    "]);return Nr=function(){return e},e}function Ir(){var e=Fr(["\n        uniform mat4 directionalShadowMatrix[ "," ];\n        varying vec4 vDirectionalShadowCoord[ "," ];\n    "]);return Ir=function(){return e},e}function Fr(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Er(e,n,t){e.options.shadows&&(e.add(Ue),e.options.numDirLights&&n.p(Ir(),e.options.numDirLights,e.options.numDirLights),e.options.numSpotLights&&n.p(Nr(),e.options.numSpotLights,e.options.numSpotLights),e.options.numPointLights&&n.p(Vr(),e.options.numPointLights,e.options.numPointLights),e.options.numDirLights&&t.p(Ur(),e.options.numDirLights,e.options.numDirLights),e.options.numSpotLights&&t.p(jr(),e.options.numSpotLights,e.options.numSpotLights),e.options.numPointLights&&t.p(zr(),e.options.numPointLights,e.options.numPointLights),t.p(Tr()),1===e.options.numDirLights?n(Rr()):e.options.numDirLights>1&&n(Mr(),e.options.numDirLights),1===e.options.numSpotLights?n(Cr()):e.options.numSpotLights>1&&n(kr(),e.options.numSpotLights),1===e.options.numPointLights?n(Pr()):e.options.numPointLights>1&&n(Dr(),e.options.numPointLights))}function Ar(){var e=Gr(["\n\n        struct DirectionalLight {\n            vec3 direction;\n            vec3 color;\n    \n            int shadow;\n            float shadowBias;\n            float shadowRadius;\n            vec2 shadowMapSize;\n        };\n\n        uniform DirectionalLight directionalLights[ "," ];\n\n    "]);return Ar=function(){return e},e}function Br(){var e=Gr(["\n    vEyeLookDir = vec3(0.0, 0.0, 1.0);"]);return Br=function(){return e},e}function Kr(){var e=Gr(["\n    vEyeLookDir = vec4( skinMatrix * vec4( vEyeLookDir, 0.0 ) ).xyz;\n    vEyeLookDir = normalMatrix * vEyeLookDir;"]);return Kr=function(){return e},e}function Gr(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Wr(e,n,t){e.options.eye&&(t.u({name:"irisDepth",type:"f",value:.5}),t.u({name:"corneaBulge",type:"f",value:.5}),t.u({name:"irisSize",type:"f",value:.5}),e.u({name:"irisTexture",type:"t",value:X.defaultIris}),e.u({name:"scleraTexture",type:"t",value:X.transparentBlack}),t.u({name:"reflectivity",type:"f",value:1}),t.u({name:"iris0",type:"v3",value:new RK.Vec3(1,0,0)}),t.u({name:"iris1",type:"v3",value:new RK.Vec3(0,1,0)}),t.u({name:"iris2",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"sclera0",type:"v3",value:new RK.Vec3(1,0,0)}),t.u({name:"sclera1",type:"v3",value:new RK.Vec3(0,1,0)}),t.u({name:"sclera2",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"limbus",type:"f",value:1}),t.u({name:"pupil",type:"v3",value:new RK.Vec3(0,0,0)}),t.u({name:"eyeGlow",type:"f",value:0}),t.u({name:"irisRotate",type:"f",value:0}),e.options.skinning?n(Kr()):n(Br()),t.s("start","\n        vec4 diffuseColor;\n        vec4 eyeDiffuseColor;\n        vec3 totalEmissiveRadiance = vec3(0, 0, 0);\n        float alphaFactor = 0.0;\n        float roughnessFactor = 0.0;\n        float metalnessFactor = 0.0;\n        float sheenFactor = 0.0;\n\n        {\n            vec2 uv = vUv;\n            vec3 veinsRgb = texture2D(scleraTexture, uv).rgb;\n            float weight0 = clamp(1.0 - 2.0 * veinsRgb.r, 0.0, 1.0);\n            float weight1 = clamp(1.0 - abs(-2.0 * veinsRgb.r + 1.0), 0.0, 1.0);\n            float weight2 = clamp(2.0 * veinsRgb.r - 1.0, 0.0, 1.0);\n            eyeDiffuseColor.rgb \n                = sclera0 * weight0\n                + sclera1 * weight1\n                + sclera2 * weight2;\n        }\n\n        ".concat(e.options.surfaceBake?"\n        eyeDiffuseColor.rgb = sclera2;\n            ":"","\n\n        float radius = length(vUv - vec2(0.5, 0.5)) * 2.0;\n\n        float irisMask = 0.0;\n        if (radius < irisSize)\n        {\n            vec2 irisUv = vUv - vec2(0.5, 0.5);\n            float sinRotate = sin(irisRotate);\n            float cosRotate = cos(irisRotate);\n            irisUv = vec2(\n                cosRotate * irisUv.x + sinRotate * irisUv.y,\n               -sinRotate * irisUv.x + cosRotate * irisUv.y);\n            irisUv /= irisSize;\n            irisUv += vec2(0.5, 0.5);\n            vec4 irisRgba = texture2D(irisTexture, irisUv);\n            vec3 irisRgb = irisRgba.rgb;\n            float irisA = irisRgba.a;\n            if (irisA > 0.55)\n            {\n                eyeDiffuseColor.rgb = pupil;\n            }\n            irisMask = min(irisA * 2.0, 1.0);\n            irisA = clamp(1.0 - abs(1.0 - 2.0 * irisA), 0.0, 1.0);\n\n            float irisRadius = radius / irisSize;\n            float limbusClamp = max(limbus, 1.0e-3);\n            float limbusBlend = clamp(1.0 + (irisRadius - 1.0) / limbus, 0.0, 1.0);\n            float limbusShadow = clamp(1.0 + (irisRadius - 1.0) / (2.0 * limbus), 0.0, 1.0);\n\n            ").concat(e.options.surfaceBake?"\n                limbusBlend = smoothstep(0.49, 0.51, limbusBlend);\n                ":"","\n\n            irisA *= 1.0 - limbusBlend;\n            irisMask *= 1.0 - limbusBlend;\n\n            float weight0 = clamp(1.0 - 2.0 * irisRgb.r, 0.0, 1.0);\n            float weight1 = clamp(1.0 - abs(-2.0 * irisRgb.r + 1.0), 0.0, 1.0);\n            float weight2 = clamp(2.0 * irisRgb.r - 1.0, 0.0, 1.0);\n            irisRgb\n                = iris0 * weight0\n                + iris1 * weight1\n                + iris2 * weight2;\n            irisRgb *= 1.0 - limbusShadow;\n\n            ").concat(e.options.surfaceBake?"\n            irisRgb.rgb = iris1;\n                ":"","\n    \n            eyeDiffuseColor.rgb = mix(eyeDiffuseColor.rgb, irisRgb, vec3(irisA));\n        }\n\n        ","\n        eyeDiffuseColor.rgb = SrgbToLinear(eyeDiffuseColor.rgb);\n    ")),t.s("normalInitialized","\n        GeometricContext geometry;\n        geometry.position = - vViewPosition;\n        geometry.normal = normal;\n        geometry.viewDir = normalize( vViewPosition );\n        geometry.preBakedOcclusion = 1.0;\n        "),e.options.preBakedOcclusion&&t.s("normalInitialized","\n            geometry.preBakedOcclusion = preBakedOcclusion;\n            "),t.s("end","\n        vec3 zAxis = normalize(vEyeLookDir);\n        vec3 xAxis = abs(zAxis.x) < abs(zAxis.y) ? vec3(1, 0, 0) : vec3(0, 1, 0);\n        vec3 yAxis = normalize(cross(zAxis, xAxis));\n        xAxis = cross(yAxis, zAxis);\n        mat3 viewToZ;\n        mat3 zToView;\n        zToView[0] = xAxis;\n        zToView[1] = yAxis;\n        zToView[2] = zAxis;\n        for (int r = 0; r < 3; ++r)\n        {\n            for (int c = 0; c < 3; ++c)\n            {\n                viewToZ[c][r] = zToView[r][c];\n            }\n        }\n\n        GeometricContext irisGeometry = geometry;\n        if (radius < irisSize)\n        {\n            vec3 zNormal = viewToZ * normalize(irisGeometry.normal);\n            vec3 zNormalOriginal = zNormal;\n            zNormal = 2.0 * dot(zNormal, vec3(0, 0, 1)) * vec3(0, 0, 1) - zNormal;\n            float maxDepthScale = 4.0;\n            float depthScale = clamp(irisDepth * maxDepthScale, 0.001, maxDepthScale);\n            float normalScale = 1.0 / depthScale;\n            zNormal.z *= normalScale;\n            zNormal = mix(zNormalOriginal, zNormal, irisMask);\n            zNormal = normalize(zNormal);\n            irisGeometry.normal = zToView * zNormal;\n        }\n        PhysicalMaterial irisMaterial;\n        irisMaterial.diffuseColor = saturate( eyeDiffuseColor.rgb ) * ( 1.0 - metalnessFactor );\n        irisMaterial.specularRoughness = 0.8;\n        irisMaterial.sheen = 0.0;\n        #ifdef STANDARD\n            irisMaterial.specularColor = mix( vec3( 0.04 ), eyeDiffuseColor.rgb, metalnessFactor );\n        #else\n            irisMaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), eyeDiffuseColor.rgb, metalnessFactor );\n        #endif\n        irisMaterial.specularColor = vec3(0, 0, 0);\n            \n        ReflectedLight reflectedLight;\n        CalculateLighting(\n            irisGeometry.normal, \n            irisGeometry.position, \n            irisGeometry.viewDir, \n            irisGeometry.preBakedOcclusion, \n            irisMaterial.diffuseColor,\n            irisMaterial.specularColor,\n            irisMaterial.specularRoughness,\n            irisMaterial.sheen,\n            lightingScale,\n            reflectedLight.directDiffuse, \n            reflectedLight.directSpecular, \n            reflectedLight.indirectDiffuse, \n            reflectedLight.indirectSpecular);\n        \n        GeometricContext corneaGeometry;\n        corneaGeometry.position = geometry.position;\n        corneaGeometry.normal = geometry.normal;\n        corneaGeometry.viewDir = geometry.viewDir;\n        corneaGeometry.preBakedOcclusion = geometry.preBakedOcclusion;\n        if (radius < irisSize)\n        {\n            vec3 zNormal = viewToZ * normalize(corneaGeometry.normal);\n            float depthScale = irisMask * corneaBulge * 3.0 + 1.0;\n            float normalScale = 1.0 / depthScale;\n            zNormal.z *= normalScale;\n            zNormal = normalize(zNormal);\n            corneaGeometry.normal = zToView * zNormal;\n        }\n        ".concat(e.options.surfaceBake||e.options.eyeDisableSpecular?"":"\n        PhysicalMaterial corneaMaterial;\n        corneaMaterial.diffuseColor = vec3(0, 0, 0);\n        corneaMaterial.specularRoughness = 0.0;\n        corneaMaterial.sheen = 0.0;\n        #ifdef STANDARD\n            corneaMaterial.specularColor = mix( vec3( 0.04 ), eyeDiffuseColor.rgb, metalnessFactor );\n        #else\n            corneaMaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), eyeDiffuseColor.rgb, metalnessFactor );\n        #endif\n        ReflectedLight corneaLight;\n        CalculateLighting(\n            corneaGeometry.normal, \n            corneaGeometry.position, \n            corneaGeometry.viewDir, \n            corneaGeometry.preBakedOcclusion, \n            corneaMaterial.diffuseColor,\n            corneaMaterial.specularColor,\n            corneaMaterial.specularRoughness,\n            corneaMaterial.sheen,\n            lightingScale,\n            corneaLight.directDiffuse, \n            corneaLight.directSpecular, \n            corneaLight.indirectDiffuse, \n            corneaLight.indirectSpecular);\n        reflectedLight.directDiffuse += corneaLight.directDiffuse;\n        reflectedLight.indirectDiffuse += corneaLight.indirectDiffuse;\n        reflectedLight.directSpecular += corneaLight.directSpecular;\n        reflectedLight.indirectSpecular += corneaLight.indirectSpecular;\n        ","\n\n        PhysicalMaterial material = irisMaterial;\n\n        ")),t.s("end","\n        vec3 outgoingLight \n            = reflectedLight.directDiffuse \n            + reflectedLight.indirectDiffuse \n            + reflectedLight.directSpecular \n            + reflectedLight.indirectSpecular \n            + eyeDiffuseColor.rgb * eyeGlow\n            + totalEmissiveRadiance;"),t.s("end","\n        ".concat("\n        gl_FragColor = vec4( LinearToSrgb(outgoingLight), 1 );\n    ")),e.debugFrag("directDiffuse","reflectedLight.directDiffuse"),e.debugFrag("indirectDiffuse","reflectedLight.indirectDiffuse"),e.debugFrag("directSpecular","reflectedLight.directSpecular"),e.debugFrag("indirectSpecular","reflectedLight.indirectSpecular"),e.debugFrag("totalEmissiveRadiance"),e.debugFrag("radiance"))}function Hr(e,n,t){e.options.colorAtlas&&(t.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"colorAtlasMap",type:"t",value:X.gray}),t.s("start","diffuseColor = vec4(  SrgbToLinear( texture2D( colorAtlasMap, vUv.xy * uvPosScl.z + uvPosScl.xy ).rgb ), 1.0);"),e.debugFrag("atlasColor","vec4(  SrgbToLinear( texture2D( colorAtlasMap, vUv.xy * uvPosScl.z + uvPosScl.xy ).rgb ), 1.0).rgb"))}function Xr(e,n,t){e.options.physicalAtlas&&(t.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"physicalAtlasMap",type:"t",value:X.black}),t.s("start","\n        vec4 physicalResponse = texture2D( physicalAtlasMap, vUv.xy * uvPosScl.z + uvPosScl.xy );\n        roughnessFactor = physicalResponse.r;\n        metalnessFactor = physicalResponse.g;\n        alphaFactor = physicalResponse.b;\n        sheenFactor = physicalResponse.a - 1.0/255.0 * 1.0/256.0; //we use the alpha channel for dilation, so we lose one value of precision.\n    "),e.debugFrag("roughnessAtlas","physicalResponse.r"),e.debugFrag("metalnessAtlas","physicalResponse.g"),e.debugFrag("alphaAtlas","physicalResponse.b"),e.debugFrag("sheenAtlas","physicalResponse.a"))}function Yr(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["gl_Position = mix( gl_Position, vec4( ( vUv.xy * uvPosScl.z + uvPosScl.xy ) * 2.0 - 1.0, 0.0, 1.0 ), renderToUVsValue ); // -1 to 1 is the final space."]);return Yr=function(){return e},e}function qr(e,n,t){e.options.renderToUVs&&(e.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),e.u({name:"renderToUVsValue",type:"f",value:1}),n(Yr()))}function Zr(e,n,t){e.options.clut&&(t.u({name:"clutMap",type:"t"}),t.s("end","vec3 clutUvw = SrgbToLinear(saturate(gl_FragColor.rgb));\n        int clutTileRows = 8;\n        int clutTileCols = 8;\n        int clutTileCount = clutTileRows * clutTileCols;\n        int clutTileWidth = 64;\n        int clutTileHeight = 64;\n        vec2 clutTileUv = clutUvw.xy;"),t.s("end","vec2 clutTileUvOffset = vec2(0.5 / float(clutTileWidth), 0.5 / float(clutTileHeight));\n        vec2 clutTileUvScale = vec2(1, 1) - clutTileUvOffset * 2.0;\n        clutTileUv = clutTileUv * clutTileUvScale + clutTileUvOffset;"),t.s("end","float clutTile = clutUvw.z * float(clutTileCount);\n        int clutTileIndex0 = int(min(max(clutTile, 0.0), float(clutTileCount - 1)));\n        int clutTileIndex1 = int(min(max(float(clutTileIndex0 + 1), 0.0), float(clutTileCount - 1)));\n        float clutTileT = min(max(clutTile - float(clutTileIndex0), 0.0), 1.0);\n        int clutRow0 = clutTileIndex0 / clutTileCols;\n        int clutCol0 = clutTileIndex0 - clutRow0 * clutTileCols;\n        int clutRow1 = clutTileIndex1 / clutTileCols;\n        int clutCol1 = clutTileIndex1 - clutRow1 * clutTileCols;\n        vec2 clutTile0Offset = vec2(float(clutCol0) / float(clutTileCols), float(clutRow0) / float(clutTileRows));\n        vec2 clutTile1Offset = vec2(float(clutCol1) / float(clutTileCols), float(clutRow1) / float(clutTileRows));\n        vec2 clutTileScale = vec2(1.0 / float(clutTileCols), 1.0 / float(clutTileRows));\n        vec2 clutTileUv0 = clutTileUv * clutTileScale + clutTile0Offset;\n        vec2 clutTileUv1 = clutTileUv * clutTileScale + clutTile1Offset;\n        vec3 clutSample0 = texture2D(clutMap, clutTileUv0).rgb;\n        vec3 clutSample1 = texture2D(clutMap, clutTileUv1).rgb;\n        vec3 clutSample = mix(clutSample0, clutSample1, clutTileT);\n        gl_FragColor.rgb = LinearToSrgb(clutSample);"))}function Qr(e,n,t){e.options.emissiveAtlas&&!e.options.eye&&(t.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),t.u({name:"emissiveAtlasMap",type:"t",value:X.gray}),t.s("start","\n    {\n        vec4 emissiveAndAlpha = texture2D( emissiveAtlasMap, vUv.xy * uvPosScl.z + uvPosScl.xy );\n        totalEmissiveRadiance = SrgbToLinear( emissiveAndAlpha.rgb );\n\n    }"),e.debugFrag("atlasEmissive","totalEmissiveRadiance.rgb"))}function Jr(){var e=no(["\n        vEyeLookDir = vec3(0, 0, 1);"]);return Jr=function(){return e},e}function $r(){var e=no(["\n        vec3 eyeOrigin = ((vec3(-0.311369, 31.163583, 1.68559) + vec3(-1.343672, 31.158595, 1.68559)) / 2.0) * 0.1;\n        float rotateY = (eyeConvergence * 2.0 - 1.0) * 0.5 * PI;\n        if (transformed.x > 0.0) {\n            eyeOrigin.x *= -1.0;\n            rotateY *= -1.0;\n        }\n        float lookH = (eyeLookH * 2.0 - 1.0) * 0.5 * PI;\n        float lookV = (eyeLookV * 2.0 - 1.0) * 0.5 * PI;\n        mat3 rotateMatrix = RotateY(rotateY + lookH) * RotateX(lookV);\n        transformed = rotateMatrix * (position - eyeOrigin) + eyeOrigin;\n        objectNormal = rotateMatrix * objectNormal;\n\n        vEyeLookDir = rotateMatrix * vec3(0, 0, 1);\n        "]);return $r=function(){return e},e}function eo(){var e=no(["varying vec3 vEyeLookDir;"]);return eo=function(){return e},e}function no(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function to(e){return(to="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ro(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function oo(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function io(e,n){return!n||"object"!==to(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ao(e){return(ao=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function co(e,n){return(co=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}In.directLight=function(e,n,t){if(Object.assign(e.uniforms,{directionalLights:{type:"sa",value:[],properties:{direction:{type:"v3"},color:{type:"c"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}}}),e.options.shadows){Object.assign(e.uniforms,{directionalShadowMap:{type:"tv",value:[]},directionalShadowMatrix:{type:"m4v",value:[]}})}e.options.numDirLights&&t.p(Ie(),e.options.numDirLights)},In.defaultParameters={numDirLights:0,numSpotLights:0,numRectAreaLights:0,numPointLights:0,numHemiLights:0,numEnvLights:0},it.normal=function(e,n,t,r){t.p(rt()),e.p(tt()),e.p(nt()),n(et()),n($n()),t(Jn());return t(Qn(),r,r,r),e.options.preBakedOcclusion&&t(Zn()),"normalize( normalMatrix * projectedNormal )"},Pt.perturbNormal=function(e,n,t){e.register("perturbNormal")||(t.p(ut()),t.p(ct()))},Wr.directLight=function(e,n,t){if(Object.assign(e.uniforms,{directionalLights:{type:"sa",value:[],properties:{direction:{type:"v3"},color:{type:"c"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}}}),e.options.shadows){Object.assign(e.uniforms,{directionalShadowMap:{type:"tv",value:[]},directionalShadowMatrix:{type:"m4v",value:[]}})}e.options.numDirLights&&t.p(Ar(),e.options.numDirLights)},Wr.defaultParameters={numDirLights:0,numSpotLights:0,numRectAreaLights:0,numPointLights:0,numHemiLights:0,numEnvLights:0};var uo=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};ro(this,n),e=io(this,ao(n).call(this));var r={env:!1,skinning:!1,morphTargets:!1,morphNormals:!1,colors:!1,colorIdMorphs:void 0,bake:!1,normalMap:!1,normalMap2:!1,layers:{},clipHeight:void 0,occlusion:!1,vertexOcclusion:!1,depthWrite:!0,uv:!1,uv2:!1,occlusionTextureSize:512,blending:RK.NormalBlending,shadows:!0,sunOcclusion:CK.Settings.sunOcclusion,debugVar:void 0,envSphere:!0,preBakedOcclusion:!1,occlusionCompensate:!1,lights:!0,wireframe:!1,es3:CK.Settings.webgl2,projectedNormalMap:!1,projectedNormalMap2:!1,colorMap:!1,colorAtlas:!1,normalAtlas:!1,physicalAtlas:!1,renderToUVs:!1,volumeFieldNormal:!1,volumeTextureSize:void 0,surface:!1,subsurface:!1,clut:!1,frostbiteSpecularOcclusion:!!CK.Settings.frostbiteSpecularOcclusion,skinInfluenceCount:4,occlusionCombineMin:CK.Settings.occlusionCombineMin,refraction:CK.Settings.refraction,opacityMap:!1,refractionEnvMap:!1,refractionDiceHack:!1,emissiveAtlas:!1,eye:!1,eyeOrientHack:!!CK.Settings.eyeOrientHack,eyeDisableSpecular:CK.Settings.eyeDisableSpecular,maxWhite254:!1,surfaceBake:!1};return Object.assign(r,In.defaultParameters),e.init(r,t.options||{},{},t.textures||{}),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&co(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Physical");return e.add([x,W,Lr,so,E,Pt,Er,In,fr,Wr,Zr,Hr,Xr,Qr,qr,ze,lo]),this.bake&&e.add(fe),e}},{key:"setOcclusion",value:function(e,n){this.options.occlusion&&(this.setUniform("uvPosScl",e),this.setUniform("occlusionMap",n))}},{key:"setSunOcclusion",value:function(e,n){this.options.sunOcclusion&&(this.setUniform("uvPosScl",e),this.setUniform("sunOcclusionMap",n))}},{key:"setColorAtlas",value:function(e,n){this.options.colorAtlas?(this.setUniform("uvPosScl",e),this.setUniform("colorAtlasMap",n)):console.error("setting color atlas while it is disabled")}},{key:"setNormalAtlas",value:function(e,n){this.options.normalAtlas?(this.setUniform("uvPosScl",e),this.setUniform("normalAtlasMap",n)):console.error("setting normal atlas while it is disabled")}},{key:"setPhysicalAtlas",value:function(e,n){this.options.physicalAtlas?(this.setUniform("uvPosScl",e),this.setUniform("physicalAtlasMap",n)):console.error("setting physical atlas while it is disabled")}},{key:"setEmissiveAtlas",value:function(e,n){this.options.emissiveAtlas?(this.setUniform("uvPosScl",e),this.setUniform("emissiveAtlasMap",n)):console.error("setting emissive while it is disabled")}}])&&oo(t.prototype,r),o&&oo(t,o),n}(be);function so(e,n,t){e.options.eye&&(e.p(eo()),e.options.eyeOrientHack?(n.u({name:"eyeConvergence",type:"f",value:.5}),n.u({name:"eyeLookH",type:"f",value:.5}),n.u({name:"eyeLookV",type:"f",value:.5}),n($r())):n(Jr()))}function lo(e,n,t){e.options.maxWhite254&&t.s("end","\n        vec3 white254 = vec3(254.0, 254.0, 254.0) / 255.0;\n        if (all(greaterThan(gl_FragColor.xyz, white254)))\n        {\n            gl_FragColor.xyz = white254;\n        }\n    ")}function fo(e){return(fo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function po(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec2 uv = vUv;\n        vec4 texel = texture2D( texture, uv );\n        texel.rgb *= texel.a;\n        gl_FragColor = texel;"]);return po=function(){return e},e}function vo(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function ho(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function mo(e,n){return!n||"object"!==fo(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function go(e){return(go=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function yo(e,n){return(yo=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var bo=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};vo(this,n),e=mo(this,go(n).call(this));var r={skinning:!1,depthWrite:!1,debugVar:void 0,wireframe:!1,color:new RK.Vec3,points:!1,depthTest:!1,transparent:!1,texture:null,textureSize:new RK.Vec2,blending:RK.NoBlending,uv:!0};return e.init(r,t),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&yo(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"BasicTextured");return e.add([x,W,E,ze]),e.f.u({name:"texture",type:"t",value:this.options.texture}),e.f.u({name:"textureSize",type:"v2",value:this.options.textureSize}),e.f(po()),e}}])&&ho(t.prototype,r),o&&ho(t,o),n}(be);function wo(e){return(wo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function xo(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec2 uv = vUv;\n        vec4 src = texture2D( srcTexture, uv );\n        vec4 dst = texture2D( dstTexture, uv );\n        vec3 srcRgb = src.rgb;\n        vec3 dstRgb = dst.rgb;\n        float srcAlpha = src.a * opacity;\n        float dstAlpha = dst.a * (1.0 - opacity);\n        float srcRgbWeight = opacity;\n        float dstRgbWeight = 1.0 - opacity;\n        float alphaSum = srcAlpha + dstAlpha;\n        if (alphaSum > 1.0e-6)\n        {\n            srcRgbWeight = srcAlpha / alphaSum;\n            dstRgbWeight = dstAlpha / alphaSum;\n        }\n        vec3 rgb = srcRgb * srcRgbWeight + dstRgb * dstRgbWeight;\n        float a = srcAlpha + dstAlpha;\n        gl_FragColor = vec4(rgb, a);"]);return xo=function(){return e},e}function So(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Oo(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Lo(e,n){return!n||"object"!==wo(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function _o(e){return(_o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Do(e,n){return(Do=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Po=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};So(this,n),e=Lo(this,_o(n).call(this));var r={skinning:!1,depthWrite:!1,debugVar:void 0,wireframe:!1,color:new RK.Vec3,points:!1,depthTest:!1,transparent:!1,srcTexture:null,dstTexture:null,textureSize:new RK.Vec2,opacity:1,blending:RK.NoBlending,uv:!0};return e.init(r,t),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Do(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"TextureBlend");return e.add([x,W,E,ze]),e.f.u({name:"srcTexture",type:"t",value:this.options.srcTexture}),e.f.u({name:"dstTexture",type:"t",value:this.options.dstTexture}),e.f.u({name:"textureSize",type:"v2",value:this.options.textureSize}),e.f.u({name:"opacity",type:"f",value:this.options.opacity}),e.f(xo()),e}}])&&Oo(t.prototype,r),o&&Oo(t,o),n}(be);function ko(e){return(ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Co(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Mo(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ro(e,n){return!n||"object"!==ko(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function To(e){return(To=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function zo(e,n){return(zo=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var jo=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{options:{},textures:{}};return Co(this,n),(e=Ro(this,To(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,clipHeight:void 0,skinInfluenceCount:4},t.options,{depth:!0,morphNormals:!1},t.textures),e.ckReverseWinding=t.options.mirrored,e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&zo(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Depth");return e.add([x,Lr,E,Ne]),e}}])&&Mo(t.prototype,r),o&&Mo(t,o),n}(be);function Uo(e){return(Uo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Vo(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function No(e,n){return!n||"object"!==Uo(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Io(e){return(Io=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Fo(e,n){return(Fo=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Eo=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=No(this,Io(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,occlusionPasses:7,numDirLights:0,seamFin:!1,skinInfluenceCount:4},e.options,{env:!1,morphNormals:!1,shadows:!0,lights:!1}),t.ckDirShadows=!0,t.blending=RK.NoBlending,t.transparent=!1,t.depthWrite=!0,t.options.vertexOcclusion&&(t.points=!0,t.options.uv=!1),t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Fo(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"GatherAO");return e.add([x,W,Lr,E,Pt,Er,qn]),e}}])&&Vo(t.prototype,r),o&&Vo(t,o),n}(be);function Ao(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec2 atlasUv = vUv.xy * uvPosScl.z + uvPosScl.xy;\n    vec2 atlasUvScreen = atlasUv * 2.0 - 1.0;\n    gl_Position = vec4( atlasUvScreen, 0.0, 1.0 );"]);return Ao=function(){return e},e}function Bo(e,n,t){n.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),n(Ao()),t.s("end","gl_FragColor = vec4((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse), 1.0);")}function Ko(e){return(Ko="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Go(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Wo(e,n){return!n||"object"!==Ko(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Ho(e){return(Ho=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Xo(e,n){return(Xo=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Yo=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=Wo(this,Ho(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,numDirLights:0,numEnvLights:0,depthTest:!1,transparent:!1,lights:!0,subsurface:!1,env:!0,colorAtlas:!1,occlusion:!1,normalMap:!1,normalMap2:!1,physicalAtlas:!1,preBakedOcclusion:!1,emissiveAtlas:!1},e.options,{morphNormals:!1,shadows:!0,lights:!1}),t.ckDirShadows=!0,t.blending=RK.AdditiveBlending,t.transparent=!1,t.depthWrite=!1,t.options.vertexOcclusion&&(t.points=!0,t.options.uv=!1),t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Xo(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Light");return e.add([x,W,Lr,E,Pt,Er,In,fr,Hr,Xr,Qr,Bo]),e}}])&&Go(t.prototype,r),o&&Go(t,o),n}(be);function qo(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec2 atlasUv = vUv.xy * uvPosScl.z + uvPosScl.xy;\n    vec2 atlasUvScreen = atlasUv * 2.0 - 1.0;\n    gl_Position = vec4( atlasUvScreen, 0.0, 1.0 );"]);return qo=function(){return e},e}function Zo(e,n,t){n.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),n(qo()),t.s("end","\n    vec3 dPdU = dFdx( vViewPosition );\n    vec3 dPdV = dFdy( vViewPosition );\n    float stretchU = 1.0 / length( dPdU );\n    float stretchV = 1.0 / length( dPdV );\n    stretchU = UnpackFloat16(PackFloat16(stretchU));\n    gl_FragColor = vec4(PackFloat16(stretchU), PackFloat16(stretchV));\n    ")}function Qo(e){return(Qo="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Jo(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function $o(e,n){return!n||"object"!==Qo(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ei(e){return(ei=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function ni(e,n){return(ni=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var ti=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=$o(this,ei(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,numDirLights:0,depthTest:!1,transparent:!1,lights:!0},e.options,{env:!1,morphNormals:!1,shadows:!0,lights:!1}),t.ckDirShadows=!1,t.blending=RK.AdditiveBlending,t.transparent=!1,t.depthWrite=!1,t.depthTest=!1,t.options.vertexOcclusion&&(t.points=!0,t.options.uv=!1),t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&ni(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"UvStretch");return e.add([x,W,Lr,E,Zo]),e}}])&&Jo(t.prototype,r),o&&Jo(t,o),n}(be);function ri(){var e=ci(["vec3 atlasUvw = vec3(uvw.xy * uv_seamPosScl.z + uv_seamPosScl.xy, uvw.z * 0.99);\n    vec3 atlasUvwScreen = vec3(atlasUvw.xy * 2.0 - 1.0, atlasUvw.z);\n    gl_Position = vec4( atlasUvwScreen, 1.0 );\n    "]);return ri=function(){return e},e}function oi(){var e=ci(["vec3 uvw = vec3(uv, 0);"]);return oi=function(){return e},e}function ii(){var e=ci(["vec3 uvw = uv_seam;"]);return ii=function(){return e},e}function ai(){var e=ci(["attribute vec3 uv_seam;"]);return ai=function(){return e},e}function ci(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function ui(e,n,t){e.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),e.u({name:"uv_seamPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),e.u({name:"imageSize",type:"v2",value:new RK.Vec2(0,0)}),e.options.uvSeam?(n.p(ai()),n(ii())):n(oi()),n(ri()),t.s("end","\n    highp vec2 atlasUv = vUv * uvPosScl.z + uvPosScl.xy;\n    highp vec2 texelCoord = atlasUv * imageSize;\n    highp vec2 texelIndex = floor(texelCoord);\n    gl_FragColor = vec4(PackUint16(texelIndex.x), PackUint16(texelIndex.y));\n//    gl_FragColor = vec4(vUv, 0, 1);\n    ")}function si(e){return(si="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function li(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function fi(e,n){return!n||"object"!==si(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function pi(e){return(pi=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function vi(e,n){return(vi=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var di=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=fi(this,pi(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,numDirLights:0,numEnvLights:0,depthTest:!1,depthWrite:!0,transparent:!1,lights:!0,subsurface:!1,env:!0,uvSeam:!0},e.options,{morphNormals:!1,shadows:!0,lights:!1}),t.ckDirShadows=!1,t.blending=RK.AdditiveBlending,t.transparent=!1,t.depthWrite=!0,t.depthTest=!0,t.side=RK.DoubleSide,t.options.vertexOcclusion&&(t.points=!0,t.options.uv=!1),t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&vi(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Light");return e.add([x,W,Lr,E,ui]),e}}])&&li(t.prototype,r),o&&li(t,o),n}(be);function hi(e){return(hi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function mi(){var e=Li(["gl_FragColor = vec4( color, 1.0);"]);return mi=function(){return e},e}function gi(){var e=Li(["color = (color - contrastMidpoint) * contrast + contrastMidpoint;"]);return gi=function(){return e},e}function yi(){var e=Li(["color = mix( color, fog.rgb, fog.a );"]);return yi=function(){return e},e}function bi(){var e=Li(["color = RgbScaleSaturation( color, saturationScale );"]);return bi=function(){return e},e}function wi(){var e=Li(["vec3 color = textureCube( tCube, vec3( -1.0 * vObjectPosition.x, vObjectPosition.yz ) ).rgb;"]);return wi=function(){return e},e}function xi(){var e=Li(["\n                \n                    vec3 RgbScaleSaturation(vec3 rgb, float saturationScale)\n                    {\n                        vec3 desaturated = vec3((rgb.r + rgb.g + rgb.b) / 3.0);\n                        return mix(desaturated, rgb, saturationScale);\n                    }\n        \n                    uniform samplerCube tCube;\n\n                "]);return xi=function(){return e},e}function Si(){var e=Li(["vWorldPosition = worldPosition.xyz;"]);return Si=function(){return e},e}function Oi(){var e=Li(["varying vec3 vWorldPosition;"]);return Oi=function(){return e},e}function Li(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function _i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Di(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Pi(e,n){return!n||"object"!==hi(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ki(e){return(ki=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Ci(e,n){return(Ci=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Mi=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return _i(this,n),(e=Pi(this,ki(n).call(this))).init({skinning:!1,fog:!1,saturationScale:!1,skinIncludeObjectPosition:!0,contrast:!1},t),e.depthWrite=!1,e.side=RK.BackSide,e.uniforms.tCube={type:"t",value:void 0},e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Ci(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Flat");return e.add([x,E,function(e,n,t){e.p(Oi()),n(Si()),t.p(xi()),t(wi()),e.options.saturationScale&&(t.u({name:"saturationScale",type:"f",value:1}),t(bi())),e.options.fog&&(t.u({name:"fog",type:"v4",value:new RK.Vec4(0,0,0,0)}),t(yi())),e.options.contrast&&(t.u({name:"contrast",type:"f",value:1}),t.u({name:"contrastMidpoint",type:"f",value:.5}),t(gi())),t(mi())}]),e}}])&&Di(t.prototype,r),o&&Di(t,o),n}(be);function Ri(e){return(Ri="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ti(){var e=Ei(["gl_FragColor.a *= alpha;"]);return Ti=function(){return e},e}function zi(){var e=Ei(["\n                    gl_FragColor.a *= ( 1.0 - saturate( length(vWorldPosition.xz) - "," / "," ) );\n                "]);return zi=function(){return e},e}function ji(){var e=Ei(["gl_FragColor = vec4( shadowColor , 1.0 - vec3(occlusion ) );"]);return ji=function(){return e},e}function Ui(){var e=Ei(["gl_FragColor = vec4( groundColor.rgb * occlusion, groundColor.a * 1.0 );"]);return Ui=function(){return e},e}function Vi(){var e=Ei(["occlusion = mix( 1.0, occlusion, shadowStrength );"]);return Vi=function(){return e},e}function Ni(){var e=Ei(["\n                    DirectionalLight directionalLight;\n                    \n                    float occlusion = 0.0;\n\n                   ","\n                \n                        directionalLight = directionalLights[ "," ];\n                \n                        occlusion += saturate( 0.7 +  getShadow( directionalShadowMap[ "," ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ "," ] ) * 0.3 );\n                \n                    ","\n                   \n                    occlusion /= ",";\n                   \n                "]);return Ni=function(){return e},e}function Ii(){var e=Ei(["vWorldPosition = worldPosition;"]);return Ii=function(){return e},e}function Fi(){var e=Ei(["varying vec4 vWorldPosition;"]);return Fi=function(){return e},e}function Ei(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Ai(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Bi(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ki(e,n){return!n||"object"!==Ri(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Gi(e){return(Gi=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Wi(e,n){return(Wi=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Hi=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Ai(this,n),(e=Ki(this,Gi(n).call(this))).init({numDirLights:0,shadowStrength:!1,groundColor:void 0,falloffStart:void 0,falloffEnd:void 0},t,{lights:!1,shadows:!0}),e.ckDirShadows=!0,e.transparent=!0,e.depthWrite=!1,e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Wi(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Shadow");return e.add([x,E,Er,function(e,n,t){0===e.options.numDirLights&&console.error("Num dir lights set to zero. Shadow material will do nothing"),e.options.groundColor&&t.u({name:"groundColor",type:"v4",value:e.options.groundColor}),t.u({name:"shadowColor",type:"v3",value:new RK.Vec3(0,0,0)}),e.p(Fi()),n(Ii()),In.directLight(e,n,t);var r=e.options.numDirLights>1?"i":"0";t(Ni(),e.options.numDirLights>1?"for ( int i = 0; i < "+e.options.numDirLights+"; i ++ ) {":"",r,r,r,e.options.numDirLights>1?"}":"",a(e.options.numDirLights)),e.options.shadowStrength&&(t(Vi()),t.u({name:"shadowStrength",type:"f",value:1})),e.options.groundColor?t(Ui()):t(ji()),void 0!==e.options.falloffStart&&t(zi(),a(e.options.falloffStart),a(e.options.falloffEnd-e.options.falloffStart)),t.u({name:"alpha",type:"f",value:1}),t(Ti())}]),e}}])&&Bi(t.prototype,r),o&&Bi(t,o),n}(be);function Xi(e){return(Xi="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Yi(){var e=Ji(["",""]);return Yi=function(){return e},e}function qi(){var e=Ji(["",""]);return qi=function(){return e},e}function Zi(){var e=Ji(["",""]);return Zi=function(){return e},e}function Qi(){var e=Ji(["",""]);return Qi=function(){return e},e}function Ji(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function $i(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function ea(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function na(e,n){return!n||"object"!==Xi(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ta(e){return(ta=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function ra(e,n){return(ra=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var oa=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=arguments.length>2?arguments[2]:void 0;return $i(this,n),(e=na(this,ta(n).call(this))).uniforms=r.uniforms,e.transparent=r.transparent,e.init({blending:RK.NormalBlending,depthWrite:!0,fragment:"",fragmentPars:"",vertex:"",vertexPars:"",uv:!1,transparent:!1},t),e.shaderName=o||"Custom",e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&ra(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=this,n=new m(this.options,this.shaderName);return n.add([x,W,function(n,t,r){void 0!==e.options.vertexPars&&t.p(Qi(),e.options.vertexPars),void 0!==e.options.vertex&&t(Zi(),e.options.vertex),void 0!==e.options.fragmentPars&&r.p(qi(),e.options.fragmentPars),void 0!==e.options.fragment&&r(Yi(),e.options.fragment)},ze]),n}}])&&ea(t.prototype,r),o&&ea(t,o),n}(be);function ia(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function aa(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var ca=function(){function e(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];ia(this,e),this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.uniforms={},n&&(this.camera=new RK.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new RK.Scene,this.quad=new RK.Mesh(new RK.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad))}var n,t,r;return n=e,(t=[{key:"render",value:function(e,n,t,r,o){}},{key:"setMaterial",value:function(e){this.quad.material=e,this.uniforms=e.uniforms,this.material=this.quad.material}}])&&aa(n.prototype,t),r&&aa(n,r),e}();function ua(e){return(ua="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function sa(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["gl_FragColor = vec4( color , opacity );"]);return sa=function(){return e},e}function la(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function fa(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function pa(e,n){return!n||"object"!==ua(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function va(e){return(va=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function da(e,n){return(da=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var ha=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};la(this,n),e=pa(this,va(n).call(this));var r={skinning:!1,depthWrite:!0,debugVar:void 0,wireframe:!1,color:new RK.Vec3,points:!1,depthTest:!1,transparent:!1,opacity:1};return e.init(r,t),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&da(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){this.opacity<1&&(this.transparent=!0);var e=new m(this.options,"Physical");return e.add([x,E,ze]),e.f.u({name:"color",type:"v3",value:this.options.color}),e.f.u({name:"opacity",type:"f",value:this.opacity}),e.f(sa()),e}}])&&fa(t.prototype,r),o&&fa(t,o),n}(be);function ma(e){return(ma="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function ga(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function ya(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ba(e,n){return!n||"object"!==ma(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function wa(e){return(wa=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function xa(e,n){return(xa=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function Sa(e){return(Sa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Oa(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["vec4 diffuseColor;"]);return Oa=function(){return e},e}function La(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function _a(e,n){return!n||"object"!==Sa(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Da(e){return(Da=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Pa(e,n){return(Pa=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var ka=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=_a(this,Da(n).call(this))).init({bake:!0,layers:{},uv:!0,uv2:!1,colorLayers:!1,normalLayers:!1,physicalLayers:!1,depthLayers:!1,emissiveLayers:!1,occlusionTextureSize:2048,seamFin:!1},e.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1}),t.transparent=!1,t.lights=!1,t.depthWrite=!0,t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Pa(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"BakeLayers");return e.f(Oa()),e.add([x,W,E,Pt,sr,fe]),e}}])&&La(t.prototype,r),o&&La(t,o),n}(function(e){function n(){return ga(this,n),ba(this,wa(n).apply(this,arguments))}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&xa(e,n)}(n,e),t=n,(r=[{key:"setLayer",value:function(e,n,t,r){var o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0,c=n?n.getMaskPath(o,i):t.getTexturePath(o);if(n&&t.hasAAID){var u=CK.Resources.getNow(n.getAAIDPath(o,i));u&&(u.magFilter!==RK.NearestFilter&&(u.generateMipmaps=!1,u.magFilter=RK.NearestFilter,u.minFilter=RK.NearestFilter,u.needsUpdate=!0),this.setUniform("aaidMap",u))}if(void 0!==t.uvwh){var s=void 0===r?t.uvwh:new RK.Vec4(t.uvwh.x+r.x,t.uvwh.y+r.y,t.uvwh.z,t.uvwh.w);this.setUniform("uvLayerOffset_"+e,s)}e in this.layers&&this.layers[e].maskTexturePath===c||(this.removeDecal(e),this.layers[e]={decal:t,slot:a,maskTexturePath:c},this.setUniform("packedMap_"+e,CK.Resources.getNow(c)),this.needsRebuild=!0)}},{key:"removeDecal",value:function(e){if(e in this.layers){delete this.layers[e];var n="packedMap_"+e;void 0!==this.uniforms[n].value&&this.uniforms[n].value.dispose(),delete this.uniforms[n],delete this.blindlySetUniforms[n],this.needsRebuild=!0}}},{key:"setLayerColorUniform",value:function(e,n,t){this.setUniform("ckUserColor_"+e+"_"+n+"_color",t)}},{key:"setLayerPhysicalUniform",value:function(e,n,t,r,o,i){var a="ckUserPhysical_"+e+"_"+n+"_roughness",c="ckUserPhysical_"+e+"_"+n+"_metalness",u="ckUserPhysical_"+e+"_"+n+"_emissive",s="ckUserPhysical_"+e+"_"+n+"_sheen";this.setUniform(a,t),this.setUniform(c,r),this.setUniform(u,o),this.setUniform(s,i)}},{key:"setLayerEmissiveUniform",value:function(e,n,t){var r="ckUserEmissive_"+e+"_"+n+"_color";this.setUniform(r,t)}},{key:"setLayerAlphaUniform",value:function(e,n,t){var r="ckUserEmissive_"+e+"_"+n+"_alpha";this.setUniform(r,t)}},{key:"hasLayerType",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"depth";for(var n in this.layers)if(this.layers[n].decal.layerTypeCounts[e])return!0;return!1}}])&&ya(t.prototype,r),o&&ya(t,o),n}(be));function Ca(e){return(Ca="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ma(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["gl_FragColor = vec4(texture2D( map, vUv ).rgb, 1.0);"]);return Ma=function(){return e},e}function Ra(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Ta(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function za(e,n){return!n||"object"!==Ca(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function ja(e){return(ja=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Ua(e,n){return(Ua=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Va=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Ra(this,n);var r={skinning:!1,depthWrite:!0,debugVar:void 0,wireframe:!1,map:void 0,depthTest:!1,transparent:!1,uv:!0};return(e=za(this,ja(n).call(this))).init(r,t),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Ua(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"Physical");return e.add([x,W,E,ze]),e.f.u({name:"map",type:"t",value:this.options.map}),e.f(Ma()),e}}])&&Ta(t.prototype,r),o&&Ta(t,o),n}(be);function Na(e){return(Na="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Ia(){var e=Ba(["\n                        if( masksValue.a > 0.01 )gl_FragColor.b = ",";\n                        else if( masksValue.b > 0.01 )gl_FragColor.b = ",";\n                        else if( masksValue.g > 0.01 )gl_FragColor.b = ",";\n                        else if( masksValue.r > 0.01 )gl_FragColor.b = ",";\n                    "]);return Ia=function(){return e},e}function Fa(){var e=Ba(["\n                    vec3 aaID = texture2D( aaidMap, vUv ).rgb;\n                    if( mode == 1 )gl_FragColor = vec4( float( meshid ) / 255.0, aaID.r , 0.0, 1.0 );\n                    else gl_FragColor = vec4( float( meshid ) / 255.0, ",", 1.0 );\n\n                "]);return Fa=function(){return e},e}function Ea(){var e=Ba(["vDominantSkinIndex = skinIndex0.x;"]);return Ea=function(){return e},e}function Aa(){var e=Ba(["varying float vDominantSkinIndex;"]);return Aa=function(){return e},e}function Ba(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Ka(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function Ga(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Wa(e,n){return!n||"object"!==Na(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Ha(e){return(Ha=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Xa(e,n){return(Xa=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Ya=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{options:{},textures:{}};return Ka(this,n),(e=Wa(this,Ha(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,uv:!0,uv2:!0,layerCount:0},t.options,{depth:!0,morphNormals:!1},t.textures),e.ckReverseWinding=t.options.mirrored,e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Xa(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=new m(this.options,"IDs");return e.add([x,W,Lr,E,function(e,n,t){e.options.skinning&&(e.p(Aa()),n(Ea())),t.u({name:"meshid",type:"i",value:0}),t.u({name:"aaidMap",type:"t",value:X.black}),t.u({name:"mode",type:"i",value:1}),t(Fa(),e.options.skinning?"floor(vDominantSkinIndex/255.0)/255.0, mod(vDominantSkinIndex,255.0)/255.0":"0.0,0.0");for(var r=0;r<e.options.layerCount;r++)Q(e,n,t,r,!0),t(Ia(),SK.float((4*r+4)/255),SK.float((4*r+3)/255),SK.float((4*r+2)/255),SK.float((4*r+1)/255))}]),e}},{key:"setLayer",value:function(e,n){var t=this,r="l"+n;["map","patches","uvOffset","form","uvSet2","tiling","udimID"].map((function(n){var o=r+"_"+n;t.setUniform(o,e[o].value)}))}}])&&Ga(t.prototype,r),o&&Ga(t,o),n}(be);function qa(e){return(qa="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Za(){var e=ec(["\n                            textureSample = SrgbToLinear( texture2D( ",", vUv2 ) );\n                            diffuseColor = vec4( mix( diffuseColor.rgb, textureSample.rgb, aaIDContribution * textureSample.a ), 1.0 );\n                        "]);return Za=function(){return e},e}function Qa(){var e=ec([" aaIDContribution = getAAIDContribution( ",", aaID ); "]);return Qa=function(){return e},e}function Ja(){var e=ec(["\n                    vec4 textureSample;\n                    float aaIDContribution;\n                    vec3 aaID = texture2D( aaidMap, vUv ).rgb;\n                "]);return Ja=function(){return e},e}function $a(){var e=ec(["\n                    float getAAIDContribution( int id, vec3 aaID ){\n                        if( id == int( floor(aaID.r * 255.0 + 0.5 ) ) )return 1.0 - aaID.b;\n                        else if( id == int( floor(aaID.g * 255.0 + 0.5 ) ) )return aaID.b;\n                        return 0.0;\n                    }\n                   \n                "]);return $a=function(){return e},e}function ec(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function nc(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function tc(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function rc(e,n){return!n||"object"!==qa(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function oc(e){return(oc=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function ic(e,n){return(ic=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var ac=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};nc(this,n),(e=rc(this,oc(n).call(this))).materialType="ColorLayersPhysical";var r={env:!1,skinning:!1,morphTargets:!1,morphNormals:!1,colors:!1,colorIdMorphs:void 0,normalMap:!1,normalMap2:!1,aaidMap:void 0,layersByPatch:[],clipHeight:void 0,depthWrite:!0,uv:!0,uv2:!0,blending:RK.NormalBlending,shadows:!0,debugVar:void 0,envSphere:!0,lights:!0};return Object.assign(r,In.defaultParameters),e.init(r,t.options||{},{},t.textures||{}),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&ic(e,n)}(n,e),t=n,(r=[{key:"makeShader",value:function(){var e=this,n=new m(this.options,"ColorLayersPhysical");return n.add([x,W,Lr,E,Pt,function(n,t,r){r.u({name:"aaidMap",type:"t"}),r.p($a()),r(Ja()),n.options.layersByPatch.map((function(n,t){r(Qa(),t),n.map((function(n,o){var i=e.getMapName(t,o);r.u({name:i,type:"t"}),r(Za(),i)}))}))},Er,In,fr,ze]),n}},{key:"setColorTexture",value:function(e,n,t){this.setUniform(this.getMapName(e,n),t),e in this.options.layersByPatch||(this.options.layersByPatch[e]=[]),this.options.layersByPatch[e][n]={type:"texture"}}},{key:"setAAIDMap",value:function(e){this.setUniform("aaidMap",e)}},{key:"getMapName",value:function(e,n){return"map".concat(e,"_").concat(n)}}])&&tc(t.prototype,r),o&&tc(t,o),n}(be);function cc(e){return(cc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function uc(){var e=pc(["\n        gl_FragColor = vec4(screenDepth, screenDepth, screenDepth, screenDepth);\n        "]);return uc=function(){return e},e}function sc(){var e=pc(["\n    ","\n    gl_Position /= gl_Position.w;\n    ","\n    int tileIndex = int(instanceIndex);\n    int sampleIndex = tileIndex;\n    vec4 depthDirection = depthDirections[sampleIndex];\n    vec4 tileTransform = tileTransforms[tileIndex];\n    vec4 quaternion = TwoVectorQuaternion(vec3(0, 0, 1), depthDirection.xyz);\n    gl_Position.xyz = QuaternionVectorRotate(quaternion, gl_Position.xyz);\n    ","\n    vec4 depthOffset = depthOffsets[sampleIndex];\n    gl_Position.xyz += depthOffset.xyz;\n\n    ","\n    vec2 tileScale = tileTransform.xy;\n    vec2 tileOffset = tileTransform.zw;\n    gl_Position.xy *= tileScale;\n    gl_Position.xy += tileOffset;\n\n    ","\n        screenDepth = (gl_Position.z + 1.0) / 2.0;\n        "]);return sc=function(){return e},e}function lc(){var e=pc(["\n    varying float screenDepth;\n    "]);return lc=function(){return e},e}function fc(){var e=pc(["\n    attribute float instanceIndex;\n    "]);return fc=function(){return e},e}function pc(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function vc(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function dc(e,n){return!n||"object"!==cc(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function hc(e){return(hc=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function mc(e,n){return(mc=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var gc=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=dc(this,hc(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,numDirLights:0,tileRows:1,tileColumns:1,skinInfluenceCount:4,eyeOrientHack:!1},e.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,ckDirShadows:!1}),t.blending=RK.NoBlending,t.transparent=!1,t.depthWrite=!0,t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&mc(e,n)}(n,e),t=n,o=[{key:"depthChunk",value:function(e,n,t){var r=e.options.tileRows*e.options.tileColumns,o=r;n.u({name:"tileTransforms",type:"v4v",count:r}),n.u({name:"depthDirections",type:"v4v",count:o}),n.u({name:"depthOffsets",type:"v4v",count:o}),n.p(fc()),e.p(lc()),n(sc(),"","","","",""),t(uc())}}],(r=[{key:"makeShader",value:function(){var e=new SK.Shader(this.options,"Depth");return e.add([SK.chunks.common,SK.chunks.quaternion,SK.chunks.morph,so,SK.chunks.skin,SK.chunks.normal,n.depthChunk]),e}}])&&vc(t.prototype,r),o&&vc(t,o),n}(be);function yc(e){return(yc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function bc(){var e=Dc(["\n        float sample = lightSum/",";\n        ","\n        float encoded = mix(1.0 / 255.0, 1.0, sample);\n        gl_FragColor = vec4(encoded);"]);return bc=function(){return e},e}function wc(){var e=Dc(["\n                {\n                    vec3 depthDirection = depthDirections[","].xyz;\n                    vec4 quaternion = TwoVectorQuaternion(vec3(0, 0, 1), depthDirection);\n                    vec3 tileDepthPosition = QuaternionVectorRotate(quaternion, depthPosition);\n                    vec4 depthOffset = depthOffsets[","];\n                    tileDepthPosition += depthOffset.xyz;\n                    vec3 tileNormal = QuaternionVectorRotate(quaternion, screenspaceNormal);\n                \n                    vec3 tileDepthUvw = (tileDepthPosition + vec3(1)) / 2.0;\n                    vec2 depthUv = tileDepthUvw.xy;\n                    depthUv *= vec2(",", ",");\n                    depthUv += vec2(",", ",");\n                    float vertexDepth = tileDepthUvw.z;\n                    float biasedLow = vertexDepth - 0.004;\n                    float biasedHigh = vertexDepth - 0.002;\n                    float frontDepth = dot(texture2D( depthTexture, depthUv ), channelMask);\n                    float visibility = smoothstep(biasedLow, biasedHigh, frontDepth);\n                    float facing = -tileNormal.z;\n                    facing = saturate(facing);\n                    float light = visibility * facing;\n                    lightSum += light;\n                }"]);return wc=function(){return e},e}function xc(){var e=Dc(["\n        float lightSum = 0.0;\n        vec3 screenspaceNormal = normal;\n        screenspaceNormal.z *= -1.0; \n        "]);return xc=function(){return e},e}function Sc(){var e=Dc(["\n            gl_PointSize = 1.0;\n            depthPosition = gl_Position.xyz / gl_Position.w;           \n            gl_Position = vec4(",", 0.0, 1.0);\n            "]);return Sc=function(){return e},e}function Oc(){var e=Dc(["attribute float vertexID;"]);return Oc=function(){return e},e}function Lc(){var e=Dc(["\n            ","\n            depthPosition = gl_Position.xyz / gl_Position.w;\n            ","\n            vec2 atlasUv = vUv.xy * uvPosScl.z + uvPosScl.xy;\n            ","\n            vec2 offsetUv = atlasUv + texelJitter;\n            ","\n            vec2 screenUv = offsetUv * 2.0 - 1.0;\n            gl_Position = vec4( screenUv, 0.0, 1.0 );"]);return Lc=function(){return e},e}function _c(){var e=Dc(["\n        varying vec3 depthPosition;\n        "]);return _c=function(){return e},e}function Dc(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Pc(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function kc(e,n){return!n||"object"!==yc(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Cc(e){return(Cc=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Mc(e,n){return(Mc=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Rc=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=kc(this,Cc(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,volumeTextureSize:2048,uv:!0,numDirLights:0,occlusionSize:2048,tileRows:1,tileColumns:1,skinInfluenceCount:4,eyeOrientHack:!1},e.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,ckDirShadows:!1,normalMap:!1,projectedNormalMap:!1,normalAtlas:!1}),t.blending=RK.NoBlending,t.transparent=!1,t.depthWrite=!0,t.options.vertexOcclusion&&(t.points=!0,t.options.points=!0,t.options.uv=!1,t.options.volumeFieldNormal=!0,t.options.volumeTextureSize=t.options.volumeTextureSize,t.options.occlusionTextureSize=t.options.occlusionSize),t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Mc(e,n)}(n,e),t=n,o=[{key:"occlusionChunk",value:function(e,n,t){var r=e.options.tileRows,o=e.options.tileColumns,i=r*o;if(n.u({name:"uvPosScl",type:"v3",value:new RK.Vec3(0,0,1)}),n.u({name:"texelJitter",type:"v2",value:new RK.Vec2(0,0)}),n.u({name:"vertexIDOffset",type:"f",value:0}),t.u({name:"depthTexture",type:"t",value:null}),t.u({name:"depthDirections",type:"v4v",count:i}),t.u({name:"depthOffsets",type:"v4v",count:i}),t.u({name:"channelMask",type:"v4",value:new RK.Vec4(0,0,0,0)}),e.p(_c()),e.options.vertexOcclusion){n.p(Oc());var a=SK.float(e.options.occlusionSize),c=SK.float(e.options.occlusionSize),u="mod( vertexID + vertexIDOffset, ".concat(a," )"),s="floor( (vertexID + vertexIDOffset) / ".concat(a," )"),l="(".concat(u," + 0.5) / ").concat(a),f="(".concat(s," + 0.5) / ").concat(c),p="vec2(".concat(l,", ").concat(f,") * 2.0 - 1.0");n(Sc(),p)}else n(Lc(),"","","","");t(xc());for(var v=1/o,d=1/r,h=0;h<r;++h)for(var m=0;m<o;++m){var g=h*o+m;t(wc(),g,g,v,d,v*m,d*h)}t(bc(),SK.float(i),"")}}],(r=[{key:"makeShader",value:function(){var e=new SK.Shader(this.options,"Occlusion");return e.add([SK.chunks.common,SK.chunks.quaternion,SK.chunks.uv,SK.chunks.morph,so,SK.chunks.skin,SK.chunks.normal,n.occlusionChunk]),e}}])&&Pc(t.prototype,r),o&&Pc(t,o),n}(be);function Tc(e){return(Tc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function zc(){var e=Fc(["\n        float reflectiveFactor = reflectivity * fogFactor;\n         \n        float mixedR = mix( color.r, base.r, reflectiveFactor );\n        float mixedG = mix( color.g, base.g, reflectiveFactor );\n        float mixedB = mix( color.b, base.b, reflectiveFactor );\n\n        gl_FragColor = vec4(mixedR, mixedG, mixedB, 1.0);\n\n        "]);return zc=function(){return e},e}function jc(){var e=Fc(["float fogFactor = 1.0;"]);return jc=function(){return e},e}function Uc(){var e=Fc(["\n            vec4 currColor = texture2D( fogTexture, vUvQuad.xy/vUvQuad.w );\n            float fogFactor = unpackRGBAToDepth( currColor );"]);return Uc=function(){return e},e}function Vc(){var e=Fc(["\n        vec4 base = texture2D( rawTexture, vUvQuad.xy/vUvQuad.w );\n        "]);return Vc=function(){return e},e}function Nc(){var e=Fc(["\n        vUvQuad = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        "]);return Nc=function(){return e},e}function Ic(){var e=Fc(["\n        varying vec4 vUvQuad;\n        "]);return Ic=function(){return e},e}function Fc(e,n){return n||(n=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}function Ec(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Ac(e,n){return!n||"object"!==Tc(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function Bc(e){return(Bc=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Kc(e,n){return(Kc=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Gc=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=Ac(this,Bc(n).call(this,e))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,fog:!1},e.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,ckDirShadows:!1,normalMap:!1,projectedNormalMap:!1,normalAtlas:!1}),t.blending=RK.NoBlending,t.transparent=!1,t.occlusion=!1,t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Kc(e,n)}(n,e),t=n,o=[{key:"reflectorChunk",value:function(e,n,t){n.u({name:"textureMatrix",type:"m4",value:new RK.Matrix4}),t.u({name:"color",type:"v3",value:null}),t.u({name:"reflectivity",type:"f",value:null}),t.u({name:"rawTexture",type:"t",value:null}),t.u({name:"fogTexture",type:"t",value:null}),e.p(Ic()),n(Nc()),t(Vc()),e.options.fog?t(Uc()):t(jc()),t(zc())}}],(r=[{key:"makeShader",value:function(){var e=new SK.Shader(this.options,"Reflector");return e.add([SK.chunks.common,SK.chunks.morph,SK.chunks.skin,SK.chunks.packing,n.reflectorChunk]),e}}])&&Ec(t.prototype,r),o&&Ec(t,o),n}(be);function Wc(e){return(Wc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function Hc(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["\n        float screenDepth = gl_FragCoord.z / gl_FragCoord.w;\n        float fogFactor = smoothstep( fogNear, fogFar, 1.0 - screenDepth );        \n        gl_FragColor = packDepthToRGBA( fogFactor );\n        "]);return Hc=function(){return e},e}function Xc(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function Yc(e,n){return!n||"object"!==Wc(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function qc(e){return(qc=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Zc(e,n){return(Zc=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var Qc=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=Yc(this,qc(n).call(this))).init({skinning:!1,morphTargets:!1,colors:!1,colorIdMorphs:void 0,mirrored:!1,vertexOcclusion:!1,occlusionTextureSize:512,uv:!0,numDirLights:0},e.options,{env:!1,morphNormals:!1,shadows:!1,lights:!1,ckDirShadows:!1}),t.blending=RK.NoBlending,t.transparent=!1,t.depthWrite=!0,t}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&Zc(e,n)}(n,e),t=n,o=[{key:"fogChunk",value:function(e,n,t){t.u({name:"fogNear",type:"f",value:.1}),t.u({name:"fogFar",type:"f",value:.8}),t(Hc())}}],(r=[{key:"makeShader",value:function(){var e=new SK.Shader(this.options,"FogMaterial");return e.add([SK.chunks.common,SK.chunks.morph,SK.chunks.skin,SK.chunks.packing,n.fogChunk]),e}}])&&Xc(t.prototype,r),o&&Xc(t,o),n}(be);function Jc(e){return(Jc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function $c(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function eu(e,n){return!n||"object"!==Jc(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function nu(e){return(nu=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function tu(e,n){return(tu=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var ru=function(e){function n(){var e;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(e=eu(this,nu(n).call(this))).setMaterial(new SK.Custom({depthWrite:!1,uv:!0,transparent:!1,blending:RK.NoBlending,vertex:"\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                ",fragmentPars:"\n                    uniform sampler2D accumulateTexture;\n                    uniform sampler2D sampleTexture;\n                    uniform vec4 channelMask;\n                ",fragment:"\n                    ".concat("\n                    vec4 accumulate = texture2D(accumulateTexture, vUv);\n                    vec4 bytes = round(accumulate * 255.0);\n                    float bits15_12 = floor(bytes.b / 16.0 + 0.5);\n                    float bits11_08 = bytes.b - (bits15_12 * 16.0);\n                    float valueSum \n                        = bytes.r * 16.0\n                        + bytes.g / 16.0\n                        + bits15_12 / 256.0;\n                    float countSum\n                        = bits11_08 * 256.0\n                        + bytes.a;\n                    ","\n                    vec4 sample = texture2D(sampleTexture, vUv);\n                    sample *= channelMask;\n                    sample = floor(sample * 255.0 + 0.5) / 255.0; // For iOS - just in case\n                    vec4 hasValue = step(vec4(1.0 / 512.0), sample);\n                    vec4 values = saturate((sample - vec4(1) / vec4(255)) / (vec4(1) - vec4(1) / vec4(255)));\n                    float value = dot(values, hasValue);\n                    float count = dot(hasValue, vec4(1));\n                    value /= max(count, 1.0); ","\n                    ","\n                    float maxCount = 4095.0; ","\n                    if (countSum < maxCount - 0.5)\n                    {\n                        valueSum += value;\n                        countSum += round(min(count, 1.0)); ","\n                    }\n                    ","\n                    bytes.r = floor(valueSum / 16.0);\n                    valueSum -= bytes.r * 16.0;\n                    bytes.g = floor(valueSum * 16.0);\n                    valueSum -= bytes.g / 16.0;\n                    bits15_12 = floor(valueSum * 256.0);\n                    bits11_08 = floor(countSum / 256.0);\n                    countSum = mod(countSum, 256.0);\n                    bytes.b \n                        = bits15_12 * 16.0\n                        + bits11_08;\n                    bytes.a = countSum;\n                    accumulate = bytes / 255.0;\n                    gl_FragColor = accumulate;\n                ")},{uniforms:{accumulateTexture:{type:"t",value:null},sampleTexture:{type:"t",value:null},channelMask:{type:"v4",value:RK.Vec4(1,1,1,1)}},transparent:!1},"AccumulateOcclusion")),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&tu(e,n)}(n,e),t=n,(r=[{key:"render",value:function(e,n,t,r,o){this.uniforms.accumulateTexture.value=t,this.uniforms.sampleTexture.value=r,this.uniforms.channelMask.value=o,CK.renderManager.renderer.autoClear=!1,e.render(this.scene,this.camera,n,!1)}}])&&$c(t.prototype,r),o&&$c(t,o),n}(ca);function ou(e){return(ou="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function iu(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function au(e,n){return!n||"object"!==ou(n)&&"function"!=typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function cu(e){return(cu=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function uu(e,n){return(uu=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var su=function(e){function n(){var e;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(e=au(this,cu(n).call(this))).setMaterial(new SK.Custom({depthWrite:!1,uv:!0,transparent:!1,blending:RK.NoBlending,vertex:"\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                ",fragmentPars:"\n                    uniform sampler2D accumulateTexture;\n                ",fragment:"\n                    vec4 accumulate = texture2D(accumulateTexture, vUv);\n                    vec4 bytes = round(accumulate * 255.0);\n                    float bits15_12 = floor(bytes.b / 16.0 + 0.5);\n                    float bits11_08 = bytes.b - (bits15_12 * 16.0);\n                    float valueSum \n                        = bytes.r * 16.0\n                        + bytes.g / 16.0\n                        + bits15_12 / 256.0;\n                    float countSum\n                        = bits11_08 * 256.0\n                        + bytes.a;\n                    if (countSum < 0.5)\n                    {\n                        gl_FragColor = vec4(0, 0, 0, 0);\n                    }\n                    else\n                    {\n                        float meanValue = valueSum / countSum;\n                        float aoValue = meanValue * 4.0;\n                        gl_FragColor = vec4(vec3(1.0 - aoValue, 1.0 - aoValue, 1.0), 1.0);\n                    }\n                "},{uniforms:{accumulateTexture:{type:"t",value:null}},transparent:!1},"ResolveOcclusion")),e}var t,r,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&uu(e,n)}(n,e),t=n,(r=[{key:"render",value:function(e,n,t){this.uniforms.accumulateTexture.value=t,CK.renderManager.renderer.autoClear=!1,e.render(this.scene,this.camera,n,!1)}}])&&iu(t.prototype,r),o&&iu(t,o),n}(ca);console.log("SK ".concat("Production 4/12/20 11:14:9 B:release/hf_2020_04_03 V14102"));var lu={clip:O,colors:Te,common:x,debug:ze,depthpack:Ne,gather:qn,layers:sr,lightCommon:In,lightPhysical:fr,morph:Lr,normal:Pt,packing:Ue,quaternion:function(e,n,t){e.p(_r())},shadow:Er,skin:E,uv:W,bake:fe};window.SK={ColorLayersPhysical:ac,chunks:lu,vec2:r,vec3:o,vec4:i,float:a,box3:c,toSL:u,mat4:s,Physical:uo,BasicTextured:bo,TextureBlend:Po,Depth:jo,GatherAO:Eo,LightMaterial:Yo,UvSeamMaterial:di,UvStretchMaterial:ti,Shader:m,Cube:Mi,ShadowReceiver:Hi,Custom:oa,Material:be,EffectPass:ca,Basic:ha,BakeLayers:ka,Patched:Pe,Map:Va,ID:Ya,DepthTileMaterial:gc,OcclusionMaterial:Rc,ReflectorMaterial:Gc,FogMaterial:Qc,AccumulateOcclusion:ru,ResolveOcclusion:su,Textures:X}}});
//# sourceMappingURL=dev/shaderkit.js.map